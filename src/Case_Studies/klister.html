<!DOCTYPE html>
<html  lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

      <title>4.3. Klister: A First Pass Performance Engineering</title>
    
          <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/theme.css " type="text/css" />
          <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/css/s4defs-roles.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/css/iframe.css" type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../../_static/theme-vendors.js"></script> -->
      <script src="../../_static/theme.js" defer></script>
    
  <link rel="index" title="Index" href="../../genindex.html" />
  <link rel="search" title="Search" href="../../search.html" />
  <link rel="next" title="Glossary" href="../glossary.html" />
  <link rel="prev" title="4.2. SBV and the Bizarre GHC Regression" href="sbv_642.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../contents.html" class="home-link">
    
      <span class="site-name">Haskell Optimization Handbook</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">

  
    <div class="nav-item">
      <a href="../../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../../contents.html#indices-and-tables"
         class="nav-link ">
         indices and tables
      </a>
    </div>
  



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            

  
    <div class="nav-item">
      <a href="../../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../../contents.html#indices-and-tables"
         class="nav-link ">
         indices and tables
      </a>
    </div>
  



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Quick search</span>
    <div class="searchformwrapper">
      <form class="search" action="../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Search" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../contents.html#haskell-optimization-handbook">Table of Contents</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../Preliminaries/index.html" class="reference internal ">Preliminaries</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Measurement_Observation/index.html" class="reference internal ">Measurement, Profiling, and Observation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Optimizations/index.html" class="reference internal ">Optimizations</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="index.html" class="reference internal ">Case Studies</a>
            

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../contents.html#indices-and-tables">indices and tables</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../glossary.html" class="reference internal ">Glossary</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../contents.html">Docs</a> &raquo;</li>
    
      <li><a href="index.html"><span class="section-number">4. </span>Case Studies</a> &raquo;</li>
    
    <li><span class="section-number">4.3. </span><span class="incremental">Klister: A First Pass Performance Engineering</span></li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="sbv_642.html"
       title="previous chapter">← <span class="section-number">4.2. </span>SBV and the Bizarre GHC Regression</a>
  </li>
  <li class="next">
    <a href="../glossary.html"
       title="next chapter">Glossary →</a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <span class="target" id="klister-case-study"></span><section id="klister-a-first-pass-performance-engineering">
<h1><span class="section-number">4.3. </span><span class="incremental">Klister: A First Pass Performance Engineering</span><a class="headerlink" href="#klister-a-first-pass-performance-engineering" title="Permalink to this heading">¶</a></h1>
<p>This chapter is a case study on a first pass of performance engineering for the
<a class="reference external" href="https://github.com/gelisam/klister/">klister</a> programming language interpreter. This case study should be exemplary
of any system which is shortlived, has distinct phases of input and output, and
maintains state. To diagnose the performance issues this case study uses
<a class="reference internal" href="../Measurement_Observation/Heap_Ghc/ghc_flags.html#heap-profiling-chapter"><span class="std std-ref">Heap Profiling</span></a> with <a class="reference internal" href="../Measurement_Observation/Heap_Ghc/eventlog.html#eventlog-chapter"><span class="std std-ref">Eventlog</span></a>, <a class="reference internal" href="../Measurement_Observation/Heap_Ghc/info_table.html#ipe-chapter"><span class="std std-ref">Info Table Profiling</span></a>, <a class="reference internal" href="../Measurement_Observation/Measurement_Ghc/ticky_ticky.html#ticky-chapter"><span class="std std-ref">TickyTicky</span></a> profiling. The optimizations are simply choosing better data
structures and closing memory leaks; any intermediate level Haskeller should be
able to follow along. After reading this chapter, a reader should be able to
spot inefficient data structure use by reading code, and utilize profiling
techniques to diagnose memory performance issues and identify hot code.</p>
<p>The rest of the chapter is structured as follows. We introduce the <a class="reference external" href="https://github.com/gelisam/klister/">klister</a>
interpreter and perform a performance minded code review. We then use the
klister testsuite to identify a poor performing program. Using this program we
begin performance engineering by: identifying a problem, implementing a change,
testing that the change was effective, and then repeating the process having
either made progress or by changing another part of the interpreter.</p>
<section id="introduction-to-the-system">
<h2><span class="section-number">4.3.1. </span>Introduction to the System<a class="headerlink" href="#introduction-to-the-system" title="Permalink to this heading">¶</a></h2>
<p>The system we are analyzing is the interpreter for <a class="reference external" href="https://github.com/gelisam/klister/">klister</a>. Klister is an
interpreted scheme-like programming language. The exact kind of language is not
particularly relevant, but one can expect it to have typical scheme features
such as s-expression syntax, hygenic macros and lexical scoping. All we need to
know about that the klister interpreter inputs a program, parses the program,
maintains mutable stores of variables and outputs a result.</p>
<p>To begin performance engineering we’ll review the subsystems that compose the
interpreter. In klister, there are 4 major subsystem:</p>
<ol class="arabic simple">
<li><p>Parser: The system that lexes and tokenizes. Klister employs <a class="reference external" href="https://hackage.haskell.org/package/megaparsec">MegaParsec</a> for
its parser.</p></li>
<li><p>Expander: Klister is a scheme-like language with hygenic macros. This
subsystem performs the macro expansion and elaboration typical to these
kinds of programming languages.</p></li>
<li><p>Type Checker: Klister is a pure functional language with Hindley-Milner type
checking and higher-ordered types, including type safe macros. This subsystem
type checks klister code.</p></li>
<li><p>Evaluator: The evaluator inputs an abstract syntax tree which represents a
klister program, executes program in the Haskell runtime system and
outputs the result.</p></li>
</ol>
</section>
<section id="characterizing-the-problem">
<h2><span class="section-number">4.3.2. </span>Characterizing the Problem<a class="headerlink" href="#characterizing-the-problem" title="Permalink to this heading">¶</a></h2>
<p>Our goal is to speed up the klister interpreter, but this goal is too vague and
is not actionable. We first need to be able to make statements that are precise
enough to be actionable. That is, we need to have a reproducible test to observe
where time is spent, and, where and how much memory is allocated and consumed.
Then we can correlate these costs to particular subsystems in the interpreter.
For example, we wish to be able to say “The parser finishes a 100 line program
in 100ms and runs in 100Kb of constant space, but the expander allocates 2Gb and
finishes its computation in 2 minutes!”. Once we can make precise statements, we
can begin forming hypotheses to speed up the system.</p>
<p>We’ll use klister’s testsuite to find a reproducible test. The testsuite
provides good sample of programs and will allow us to find a <em>degenerate</em>
program. With a degenerate program, we’ll record and correlate runtime costs to
each subsystem and find the offending piece of source code.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A quick note on these degenerate programs and a mental model that you might
find useful. In the abstract, we can think about the <em>system space</em> of the
system. The system space is the space of all possible semantically equivalent
systems, for some input and for some available resources. For example, for
klister, given the input program <code class="docutils literal notranslate"><span class="pre">(+</span> <span class="pre">2</span> <span class="pre">2)</span></code> we have an infinite space of
possible klister interpreters, some with many machine resources and some with
few. Similarly, given the same machine to run the klister interpreter, and
the same input program, we still have an infinite space of klister
interpreters, some of which will be very fast (in wall time) and some will be
very slow, depending on their implementation.</p>
<p>Now we can imagine that there are boundaries <a class="footnote-reference brackets" href="#id8" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> in this system space that
delineate acceptable performance from unacceptable performance, however one
defines performance and what is acceptable. These degenerate programs are
inputs <em>that point to such a boundary</em>, and thus they are useful allies in our
performance work. As we improve the interpreter these boundaries will change,
the space of acceptability will grow and we’ll have to find even more
degenerate programs to observe the boundaries again.</p>
</div>
</section>
<section id="performance-minded-code-review">
<h2><span class="section-number">4.3.3. </span>Performance Minded Code Review<a class="headerlink" href="#performance-minded-code-review" title="Permalink to this heading">¶</a></h2>
<p>Before running the testsuite, we’ll begin with a code review to better
understand the interpreter and to read through the code with a performance
engineering mindset. Here is a list of things that are noticeable from reading
through the source code.</p>
<ol class="arabic simple">
<li><p>Lazy <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> in the interpreter state.</p></li>
<li><p>Lazy <code class="docutils literal notranslate"><span class="pre">modifyIORef</span></code> in the interpreter state.</p></li>
<li><p>Use of lazy tuples throughout the code base.</p></li>
<li><p>Lists used as general purpose containers.</p></li>
<li><p>Lazy State Monad especially in the Expander.</p></li>
<li><p>Lazy WriterT monad transformer in the Expander.</p></li>
<li><p>Use of Monad Transformers and ExceptT in the interpreter state.</p></li>
<li><p>Lack of Specialization, especially in <code class="docutils literal notranslate"><span class="pre">IORef</span></code> utilities module and in lens
driven code.</p></li>
<li><p>Some modules do not use explicit exports.</p></li>
<li><p>No use of <code class="docutils literal notranslate"><span class="pre">-funbox-strict-fields</span></code> for bang patterns or <code class="docutils literal notranslate"><span class="pre">UNPACK</span></code> pragmas.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">foldr</span></code> on a list (see <code class="docutils literal notranslate"><span class="pre">Expander.getExports</span></code>) even though the code
does not exploit laziness.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">Integer</span></code> instead of <code class="docutils literal notranslate"><span class="pre">Int</span></code>.</p></li>
</ol>
<p>We won’t being going through each in detail, but instead just highlight a few
consequential items. Note that not all of these need to be fixed or are
categorically a mistake. It depends on what the system is trying to do and how
the implementation is trying to realize the system. For example, there might be
a perfectly good reason to use an <code class="docutils literal notranslate"><span class="pre">Integer</span></code> over an <code class="docutils literal notranslate"><span class="pre">Int</span></code>, such as one
expects to handle data past the <code class="docutils literal notranslate"><span class="pre">Int</span></code> range.</p>
<section id="data-map-with-expensive-keys">
<h3><span class="section-number">4.3.3.1. </span>Data.Map With Expensive Keys<a class="headerlink" href="#data-map-with-expensive-keys" title="Permalink to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ExpanderState</span></code> is a key type in the klister interpreter. It is stored in
an <code class="docutils literal notranslate"><span class="pre">IORef</span></code> and maintains state for the expander. From a performance
perspective the <code class="docutils literal notranslate"><span class="pre">ExpanderState</span></code> is suspect because it employs data structures
that are lazy and yet the interpreter will eventually use everything in the
state. Here is the definition of the <code class="docutils literal notranslate"><span class="pre">ExpanderState</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="kr">data</span><span class="w"> </span><span class="kt">ExpanderState</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">ExpanderState</span><span class="w"></span>
<span class="p">{</span><span class="w"> </span><span class="n">_expanderWorld</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">World</span><span class="w"> </span><span class="kt">Value</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderNextScopeNum</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Int</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderGlobalBindingTable</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">BindingTable</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderExpansionEnv</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">ExpansionEnv</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderTasks</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[(</span><span class="kt">TaskID</span><span class="p">,</span><span class="w"> </span><span class="kt">ExpanderLocal</span><span class="p">,</span><span class="w"> </span><span class="kt">ExpanderTask</span><span class="p">)]</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderOriginLocations</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">SplitCorePtr</span><span class="w"> </span><span class="kt">SrcLoc</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedCore</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">SplitCorePtr</span><span class="w"> </span><span class="p">(</span><span class="kt">CoreF</span><span class="w"> </span><span class="kt">TypePatternPtr</span><span class="w"> </span><span class="kt">PatternPtr</span><span class="w"> </span><span class="kt">SplitCorePtr</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedPatterns</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">PatternPtr</span><span class="w"> </span><span class="p">(</span><span class="kt">ConstructorPatternF</span><span class="w"> </span><span class="kt">PatternPtr</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedTypePatterns</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">TypePatternPtr</span><span class="w"> </span><span class="kt">TypePattern</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderPatternBinders</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">PatternPtr</span><span class="w"> </span><span class="p">(</span><span class="kt">Either</span><span class="w"> </span><span class="p">[</span><span class="kt">PatternPtr</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">Scope</span><span class="p">,</span><span class="w"> </span><span class="kt">Ident</span><span class="p">,</span><span class="w"> </span><span class="kt">Var</span><span class="p">,</span><span class="w"> </span><span class="kt">SchemePtr</span><span class="p">)))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderTypePatternBinders</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">TypePatternPtr</span><span class="w"> </span><span class="p">[(</span><span class="kt">Scope</span><span class="p">,</span><span class="w"> </span><span class="kt">Ident</span><span class="p">,</span><span class="w"> </span><span class="kt">Var</span><span class="p">,</span><span class="w"> </span><span class="kt">SchemePtr</span><span class="p">)])</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedTypes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">SplitTypePtr</span><span class="w"> </span><span class="p">(</span><span class="kt">TyF</span><span class="w"> </span><span class="kt">SplitTypePtr</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedDeclTrees</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">DeclTreePtr</span><span class="w"> </span><span class="p">(</span><span class="kt">DeclTreeF</span><span class="w"> </span><span class="kt">DeclPtr</span><span class="w"> </span><span class="kt">DeclTreePtr</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedDecls</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">DeclPtr</span><span class="w"> </span><span class="p">(</span><span class="kt">Decl</span><span class="w"> </span><span class="kt">SplitTypePtr</span><span class="w"> </span><span class="kt">SchemePtr</span><span class="w"> </span><span class="kt">DeclTreePtr</span><span class="w"> </span><span class="kt">SplitCorePtr</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderModuleTop</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">DeclTreePtr</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderModuleImports</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Imports</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderModuleExports</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Exports</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderPhaseRoots</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="kt">Scope</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderModuleRoots</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">ModuleName</span><span class="w"> </span><span class="kt">Scope</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderKernelBindings</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">BindingTable</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderKernelExports</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Exports</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderKernelDatatypes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">Datatype</span><span class="w"> </span><span class="kt">DatatypeInfo</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderKernelConstructors</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">Constructor</span><span class="w"> </span><span class="p">(</span><span class="kt">ConstructorInfo</span><span class="w"> </span><span class="kt">Ty</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderKernelValues</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Env</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="p">(</span><span class="kt">SchemePtr</span><span class="p">,</span><span class="w"> </span><span class="kt">Value</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderDeclOutputScopes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">DeclOutputScopesPtr</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCurrentEnvs</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">Env</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="kt">Value</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCurrentTransformerEnvs</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">Env</span><span class="w"> </span><span class="kt">MacroVar</span><span class="w"> </span><span class="kt">Value</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCurrentDatatypes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">Datatype</span><span class="w"> </span><span class="kt">DatatypeInfo</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCurrentConstructors</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">Constructor</span><span class="w"> </span><span class="p">(</span><span class="kt">ConstructorInfo</span><span class="w"> </span><span class="kt">Ty</span><span class="p">)))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCurrentBindingTable</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">BindingTable</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderExpressionTypes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">SplitCorePtr</span><span class="w"> </span><span class="kt">Ty</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedSchemes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="kt">SchemePtr</span><span class="w"> </span><span class="p">(</span><span class="kt">Scheme</span><span class="w"> </span><span class="kt">Ty</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderTypeStore</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">TypeStore</span><span class="w"> </span><span class="kt">Ty</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderKindStore</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">KindStore</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderDefTypes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">TypeContext</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="kt">SchemePtr</span><span class="p">)</span><span class="w"> </span><span class="c1">-- ^ Module-level definitions</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>These <code class="docutils literal notranslate"><span class="pre">Maps</span></code> are suspicious because every type suffixed with <code class="docutils literal notranslate"><span class="pre">Ptr</span></code> is a
newtype over an <code class="docutils literal notranslate"><span class="pre">Integer</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">SplitCorePtr</span></code> is an newtype over a
<code class="docutils literal notranslate"><span class="pre">Unique</span></code> which is itself a newtype over <code class="docutils literal notranslate"><span class="pre">Integer</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">SplitCorePtr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">SplitCorePtr</span><span class="w"> </span><span class="kt">Unique</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">Unique</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Unique</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This means that <code class="docutils literal notranslate"><span class="pre">klister</span></code> has a lot of <code class="docutils literal notranslate"><span class="pre">Maps</span></code> effectively indexed on
<code class="docutils literal notranslate"><span class="pre">Integer</span></code>. Clearly an <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> would be a better choice of data structure.
An <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> has several advantages over <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>. <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> is an
implementation of <em>size balanced binary trees</em> (see the <a class="reference external" href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Map.html">hackage</a>
docs). These trees require re-balancing in order to maintain the balanced
invariant. This balancing slows down writes (that is, adds work to
<code class="docutils literal notranslate"><span class="pre">Data.Map.insert</span></code>) and consequently merges, because a merge of any two trees
may invoke a re-balancing. In contrast, <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> is a big-endian PATRICIA Trie
(see <span id="id2">Okasaki [<a class="reference internal" href="../../contents.html#id17" title="Chris Okasaki. Purely Functional Data Structures. Cambridge University Press, 1998. doi:10.1017/CBO9780511530104.">5</a>]</span>) which never require balancing. Compared to <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>,
an <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> provides faster writes at the cost of slightly slower reads.
Additionally, <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> uses less total memory than <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> <a class="footnote-reference brackets" href="#id9" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<p>The klister interpreter also uses <code class="docutils literal notranslate"><span class="pre">Map</span></code>’s indexed over <code class="docutils literal notranslate"><span class="pre">String</span></code> like types.
For example, <code class="docutils literal notranslate"><span class="pre">_expanderKernelDatatypes</span></code> is a <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">Datatype</span> <span class="pre">DatatypeInfo</span></code>,
where <code class="docutils literal notranslate"><span class="pre">DataType</span></code> is a record:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Datatype</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Datatype</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">_datatypeModule</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">ModuleName</span><span class="w"> </span><span class="c1">-- ^ The module that defines the datatype</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">_datatypeName</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">DatatypeName</span><span class="w"> </span><span class="c1">-- ^ The unique name for the datatype at this module and phase</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ModuleName</span></code> and <code class="docutils literal notranslate"><span class="pre">DatatypeName</span></code> are a <code class="docutils literal notranslate"><span class="pre">String</span></code> and <code class="docutils literal notranslate"><span class="pre">Text</span></code>
respectively:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">ModuleName</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">ModuleName</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">KernelName</span><span class="w"> </span><span class="kt">KernelName</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>

<span class="kr">newtype</span><span class="w"> </span><span class="kt">DatatypeName</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">DatatypeName</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_datatypeNameText</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Text</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="kr">newtype</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">IsString</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Hashable</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="n">stock</span><span class="w"> </span><span class="kt">Data</span><span class="w"></span>
</pre></div>
</div>
<p>Indexing over <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> over <code class="docutils literal notranslate"><span class="pre">String</span></code> like types is a performance
anti-pattern. In the worse case, the <code class="docutils literal notranslate"><span class="pre">Ord</span></code> and <code class="docutils literal notranslate"><span class="pre">Eq</span></code> instance on <code class="docutils literal notranslate"><span class="pre">String</span></code>
will need to check the entire <code class="docutils literal notranslate"><span class="pre">String</span></code>. Even in the average case, the extra
comparisons will be required in order to rebalance the tree, which will slow
down writes and merges.</p>
<p>A better datastructure for maps indexed over <code class="docutils literal notranslate"><span class="pre">String</span></code> like types is
<code class="docutils literal notranslate"><span class="pre">Data.HashMap</span></code> from the <code class="docutils literal notranslate"><span class="pre">unordered-containers</span></code> library. These maps are
<em>Hashed Array Mapped Trie’s</em>, or HAMTs for short (see <span id="id4">Bagwell [<a class="reference internal" href="../../contents.html#id18" title="Phil Bagwell. Ideal hash trees. Technical Report, Ecole polytechnique fédérale de Lausanne, 2001.">6</a>]</span>).
HAMTs index over a <code class="docutils literal notranslate"><span class="pre">hash</span></code> that uniquely represents the key. These data
structures are efficient for any key type where equality could be expensive;
such as <code class="docutils literal notranslate"><span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">Text</span></code> or inductive data types that derive <code class="docutils literal notranslate"><span class="pre">Eq</span></code>.</p>
</section>
<section id="lazy-tuples">
<h3><span class="section-number">4.3.3.2. </span>Lazy Tuples<a class="headerlink" href="#lazy-tuples" title="Permalink to this heading">¶</a></h3>
<p>Consider this field of the <code class="docutils literal notranslate"><span class="pre">ExpanderState</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderTypePatternBinders</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span><span class="w"> </span><span class="kt">TypePatternPtr</span><span class="w"> </span><span class="p">[(</span><span class="kt">Scope</span><span class="p">,</span><span class="w"> </span><span class="kt">Ident</span><span class="p">,</span><span class="w"> </span><span class="kt">Var</span><span class="p">,</span><span class="w"> </span><span class="kt">SchemePtr</span><span class="p">)])</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>The elements of this map is a list of 4-tuples. This list will have an excessive
amount of indirection to its values. Not only will the interpreter be chasing
pointers in the elements of the list but it’ll have to chase pointers for each
element of the tuple. This will be slow if these lists ever become large (over
~30 elements) and if this list will be the subject of folds. For this specific
datatype, there is one fold in the klister interpreter:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">else</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">varInfo</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="p">(</span><span class="n">expanderTypePatternBinders</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">patPtr</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getState</span><span class="w"></span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">varInfo</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">Nothing</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">throwError</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">InternalError</span><span class="w"> </span><span class="s">&quot;Type pattern info not added&quot;</span><span class="w"></span>
<span class="w">    </span><span class="kt">Just</span><span class="w"> </span><span class="n">vars</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">      </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"></span>
<span class="w">      </span><span class="kr">let</span><span class="w"> </span><span class="n">rhs&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="n">addScope</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">stx</span><span class="w"></span>
<span class="w">                   </span><span class="p">[</span><span class="w"> </span><span class="n">sc&#39;</span><span class="w"></span>
<span class="w">                   </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">sc&#39;</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">vars</span><span class="w"></span>
<span class="w">                   </span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="n">withLocalVarTypes</span><span class="w"></span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="p">(</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">varStx</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">_sc</span><span class="p">,</span><span class="w"> </span><span class="n">varStx</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">vars</span><span class="w"></span>
<span class="w">        </span><span class="p">]</span><span class="w"> </span><span class="o">$</span><span class="w"></span>
<span class="w">        </span><span class="n">expandOneExpression</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="n">dest</span><span class="w"> </span><span class="n">rhs&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>The code projects <code class="docutils literal notranslate"><span class="pre">expanderTypePatternBinders</span></code> and looks up the list that
<code class="docutils literal notranslate"><span class="pre">patPtr</span></code> points to. It then iterates over that <em>same</em> list twice: First, to
project the <code class="docutils literal notranslate"><span class="pre">sc'</span></code> from the first position and pass it to <code class="docutils literal notranslate"><span class="pre">addScope</span></code>. Second,
to project the second, third and fourth positions into a list of 3-tuples and
pass that to <code class="docutils literal notranslate"><span class="pre">withLocalVarTypes</span></code>. This code can be improved with <a class="reference internal" href="../glossary.html#term-Loop-Fusion"><span class="xref std std-term">Loop
Fusion</span></a> to iterate over the list once, using <code class="docutils literal notranslate"><span class="pre">foldl'</span></code> instead of <code class="docutils literal notranslate"><span class="pre">foldr</span></code>,
and by defining a datatype which unpacks every field instead of using <code class="docutils literal notranslate"><span class="pre">(,,,)</span></code>
to avoid the extra allocation for these tuples. Note that defining a such a
datatype will require that <span class="math notranslate nohighlight">\(\bot\)</span> is never an element of the 4-tuple. In this
case that will be true, but it is not true in general; again, in order to
optimize you must <a class="reference internal" href="../Measurement_Observation/the_recipe.html#understand-the-system"><span class="std std-ref">understand the system</span></a>.</p>
<p>Generally types such as <code class="docutils literal notranslate"><span class="pre">(,,,)</span></code> are a path of least resistance when writing
new code. They are easy to reach for, easy to write and don’t require more
domain modeling. However, tuples, and especially tuples with more than two
fields, are a consistent source of memory leaks. So one is almost always better
off defining a datatype instead of using a tuple for performance.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Of course, you may not want to add yet another datatype to the
implementation. One may want the datatypes in the implementation to map
cleanly to domain objects. This a classic tradeoff between performance,
readability and maintainability.</p>
</div>
</section>
<section id="running-the-testsuite">
<h3><span class="section-number">4.3.3.3. </span>Running the testsuite<a class="headerlink" href="#running-the-testsuite" title="Permalink to this heading">¶</a></h3>
<p>Klister does not have a benchmark suite, but does have a testsuite (with 124
tests) written in <a class="reference internal" href="../Measurement_Observation/Measurement_Libs/criterion.html#tasty-chapter"><span class="std std-ref">tasty</span></a> which outputs the wall time of
each test. So let’s run the testsuite to find a degenerate test:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cabal <span class="nb">test</span> --test-show-details<span class="o">=</span>streaming  --ghc-options<span class="o">=</span><span class="s1">&#39;-O2&#39;</span>

<span class="go">  Test suite klister-tests: RUNNING...</span>
<span class="go">  All tests</span>
<span class="go">    Expander tests</span>
<span class="go">      ...</span>
<span class="go">      Module tests</span>
<span class="go">        Expected to succeed</span>
<span class="go">          ...</span>
<span class="go">          examples/lang.kl:                              OK (0.04s)</span>
<span class="go">          examples/import.kl:                            OK (0.02s)</span>
<span class="go">          examples/macro-body-shift.kl:                  OK (0.03s)</span>
<span class="go">          examples/test-quasiquote.kl:                   OK (0.05s)</span>
<span class="go">          examples/quasiquote-syntax-test.kl:            OK (0.04s)</span>
<span class="go">          examples/hygiene.kl:                           OK (0.84s)</span>
<span class="go">          examples/defun-test.kl:                        OK (0.01s)</span>
<span class="go">          examples/fun-exports-test.kl:                  OK (0.04s)</span>
<span class="go">    Golden tests</span>
<span class="go">      test-quasiquote:                                   OK (0.03s)</span>
<span class="go">      io:                                                OK (0.03s)</span>
<span class="go">      defun-test:                                        OK (0.04s)</span>
<span class="go">      contract:                                          OK (0.11s)</span>
<span class="go">      int-ops:                                           OK (0.03s)</span>
<span class="go">      implicit-conversion:                               OK (7.02s)</span>
<span class="go">      ...</span>
<span class="go">      implicit-conversion-test:                          OK (9.89s)</span>
<span class="go">      higher-kinded-patterns:                            OK (1.80s)</span>
<span class="go">      custom-literals-test:                              OK (0.46s)</span>
<span class="go">      double-define:                                     OK (0.34s)</span>
<span class="go">      custom-module-test:                                OK (0.55s)</span>
<span class="go">      which-problem:                                     OK (0.82s)</span>
<span class="go">      incorrect-context:                                 OK (0.03s)</span>
<span class="go">      bound-vs-free:                                     OK (0.31s)</span>
<span class="go">      meta-macro:                                        OK (0.11s)</span>
<span class="go">      integer-syntax:                                    OK (0.04s)</span>
<span class="go">      import:                                            OK (0.04s)</span>

<span class="go">      All 124 tests passed (38.15s)</span>
<span class="go">      Test suite klister-tests: PASS</span>
</pre></div>
</div>
<p>The entire testsuite finishes in 38 seconds. Notice that both
<code class="docutils literal notranslate"><span class="pre">implicit-conversion</span></code> and <code class="docutils literal notranslate"><span class="pre">implicit-conversion-test</span></code> are extreme outliers,
passing in 7 and 9 <em>seconds</em>, whereas each other test passes in well under a
second (except <code class="docutils literal notranslate"><span class="pre">higher-kinded-patterns</span></code>). We have found our degenerate
program.</p>
</section>
</section>
<section id="restate-the-problem">
<h2><span class="section-number">4.3.4. </span>Restate the Problem<a class="headerlink" href="#restate-the-problem" title="Permalink to this heading">¶</a></h2>
<p>For the rest of the case study we’ll focus on speeding up
<code class="docutils literal notranslate"><span class="pre">implicit-conversion-test</span></code> under the assumption that our changes will also
speed up the other tests and consequently the entire interpreter. It is
certainly possible that optimizations in one subsystem of your code base will
not translate to better overall performance. We make this assumption because
this is the first pass of performance engineering for this code. So the
probability that our changes do impact overall performance is high.</p>
<p>We have identified a list of likely issues, but before we begin to change things
we need to make sure that the problems we’ve identified are indeed problems. Or
in other words, we should only make changes <em>once</em> we have evidence that the
code we’re changing is problematic. If the maps are a problematic factor then we
should expect a lot of allocations to come from <code class="docutils literal notranslate"><span class="pre">Data.Map.insert</span></code>, <code class="docutils literal notranslate"><span class="pre">Eq</span></code> and
<code class="docutils literal notranslate"><span class="pre">Ord</span></code> instance methods, and the functions <code class="docutils literal notranslate"><span class="pre">Data.Map.Internal.balanceR</span></code> and
<code class="docutils literal notranslate"><span class="pre">Data.Map.Internal.balanceL</span></code>. This is a good opportunity to <a class="reference internal" href="../Measurement_Observation/the_recipe.html#don-t-think-look"><span class="std std-ref">not think
and look</span></a> with a <a class="reference internal" href="../Measurement_Observation/Measurement_Ghc/ticky_ticky.html#ticky-chapter"><span class="std std-ref">ticky</span></a> report.</p>
<p>First we’ll generate a ticky report for the entire testsuite:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cabal <span class="nb">test</span> --test-show-details<span class="o">=</span>streaming --test-options<span class="o">=</span><span class="s1">&#39;+RTS -rticky -RTS&#39;</span> --ghc-options<span class="o">=</span><span class="s1">&#39;-rtsopts -ticky -ticky-allocd -ticky-dyn-thunk&#39;</span>
<span class="go">  Build profile: -w ghc-9.2.4 -O1</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>and check the results sorted by allocations. As a reminder, there are 5 columns
in a ticky report. The first column is entries. The second column is the number
of bytes allocated <em>by</em> the code for the closure. The third column is the number
of bytes <em>addressed</em> to each closure. The fourth column classifies the closure
by type with a shorthand notation, and the last column displays the names of the
Stg closure the ticky profile is describing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat ticky | tail -n +20 | sort -k2 -nr | less

  53739709 4299176720          0   3 +.&gt;                  ScopeSet.$wallScopeSets&#39;{v rNAX} (fun)
  60292448 3858716672 2149588360   3 +..                  sat_sOYl{v} (ScopeSet) (fun) in rNAX
  81547057 1368797696          0   4 SISM                 ScopeSet.$w$sgo4{v rNAW} (fun)
  57730804 1305110352          0   4 SISM                 ScopeSet.$w$sgo1{v rNAV} (fun)
  61143424  841913088          0   2 SM                   ScopeSet.isSubsetOf_go15{v rOUK} (fun)
   7819243  815587232          0   6 &gt;pii.M               Binding.$w$sgo3{v r1syq} (fun)
  17961626  421056776          0   3 &gt;MM                  Binding.$fMonoidBindingTable_$sunionWith{v r1syc} (fun)
    867831  366262720          0  10 piiSiSL&gt;&gt;&gt;           Parser.Common.$wg{v rk} (fun)
    886661  333384536          0   6 SS&gt;&gt;&gt;&gt;               located{v r1b6H} (Parser) (fun)
   4552387  298031744          0   3 ISM                  Expander.$w$sgo4{v r5BKT} (fun)
   4843152  270145008     612288   1 M                    go15{v s1szA} (Binding) (fun) in r1syd
   2699373  259139808          0   4 &gt;SSM                 Syntax.$w$cmapScopes{v rTEZ} (fun)
  18445979  240603872          0   4 piiM                 Binding.$w$sgo1{v r1syi} (fun)
   1351616  237884416     612288   1 T                    f{v s1szf} (Binding) (fun) in r1syd
   1862523  211065056          0   3 S&gt;M                  ScopeSet.$satKeyIdentity_$sgo15{v rOUv} (fun)
   3383994  186416288   43447360   2 LM                   go15{v sP96} (ScopeSet) (fun) in rOUk
    101588  145802400          0   4 MSSM                 $wexpandOneForm{v r5IwM} (Expander) (fun)
   2607448  125157504          0   2 &gt;S                   Syntax.$fHasScopesSyntax_$cmapScopes{v rTEY} (fun)
  ...
</pre></div>
</div>
<p>There are several interesting aspects to this ticky profile snippet. First, the
most allocating code is <code class="docutils literal notranslate"><span class="pre">ScopeSet.allScopeSets'</span></code>, it is allocating a
dictionary (<code class="docutils literal notranslate"><span class="pre">+</span></code>) of some type (<code class="docutils literal notranslate"><span class="pre">.</span></code>) and function (<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>). Observing a
function call to a dictionary <code class="docutils literal notranslate"><span class="pre">+</span></code> in a ticky report can often mean that a
function did not specialize. So from this ticky we suspect that
<code class="docutils literal notranslate"><span class="pre">allScopeSets'</span></code> has not specialized. The second most allocating closure is a
SAT’d function <code class="docutils literal notranslate"><span class="pre">sat_sOYl</span></code> (see <a class="reference internal" href="../Optimizations/GHC_opt/sat_transformation.html#sat-chapter"><span class="std std-ref">The Static Argument Transformation</span></a>). From its description: <code class="docutils literal notranslate"><span class="pre">{v}</span> <span class="pre">(ScopeSet)</span> <span class="pre">(fun)</span> <span class="pre">in</span> <span class="pre">rNAX</span></code>, we can see
that it is a non-exported name (<code class="docutils literal notranslate"><span class="pre">{v}</span></code>) just like <code class="docutils literal notranslate"><span class="pre">allScopeSets'</span></code>, in the
<code class="docutils literal notranslate"><span class="pre">(ScopeSet)</span></code> module. It is a function <code class="docutils literal notranslate"><span class="pre">(fun)</span></code> and is a local function in the
<code class="docutils literal notranslate"><span class="pre">rNAX</span></code> closure. The <code class="docutils literal notranslate"><span class="pre">rNAX</span></code> closure is the Stg name of the closure for
<code class="docutils literal notranslate"><span class="pre">allScopeSets'</span></code> as shown in description for <code class="docutils literal notranslate"><span class="pre">allScopeSets'</span></code>. So the two most
allocating function calls in the interpreter, when running the testsuite, are
due to <code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code>. Clearly, <code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code> is a good target for
performance engineering.</p>
<p>We also see that the 5th and 6th most allocating functions called are
<code class="docutils literal notranslate"><span class="pre">ScopeSet.isSubsetOf</span></code> and <code class="docutils literal notranslate"><span class="pre">Binding.$fMonoidBindingTable_$unionWith</span></code>. That
suggests peculiar usage pattern; <code class="docutils literal notranslate"><span class="pre">isSubsetOf</span></code> should only return a <code class="docutils literal notranslate"><span class="pre">Bool</span></code>
which should not be an allocating function call. <code class="docutils literal notranslate"><span class="pre">unionWith</span></code> should be
allocating, but that this occurs in the <code class="docutils literal notranslate"><span class="pre">Monoid</span> <span class="pre">Binding</span></code> instance means that
the <code class="docutils literal notranslate"><span class="pre">Binding</span> <span class="pre">Monoid</span></code> instance is heavily allocating. Let’s check these
functions in the source code:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">_universalScopes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="kt">Scope</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_phaseScopes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">Set</span><span class="w"> </span><span class="kt">Scope</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="kr">data</span><span class="w"> </span><span class="kt">Scope</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Scope</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">scopeNum</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">scopePurpose</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Text</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>

<span class="kr">newtype</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">phaseNum</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Natural</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>

<span class="nf">isSubsetOf</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">isSubsetOf</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">scs1</span><span class="w"> </span><span class="n">scs2</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="w"> </span><span class="p">(</span><span class="n">scopes</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">scs1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">scopes</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">scs2</span><span class="p">)</span><span class="w"></span>


<span class="nf">scopes</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="kt">Scope</span><span class="w"></span>
<span class="nf">scopes</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">scs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="n">universalScopes</span><span class="w"> </span><span class="n">scs</span><span class="w"> </span><span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">union</span><span class="p">`</span><span class="w"></span>
<span class="w">               </span><span class="n">view</span><span class="w"> </span><span class="p">(</span><span class="n">phaseScopes</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">non</span><span class="w"> </span><span class="kt">Set</span><span class="o">.</span><span class="n">empty</span><span class="p">)</span><span class="w"> </span><span class="n">scs</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ScopeSet</span></code> is a record of <code class="docutils literal notranslate"><span class="pre">Data.Set</span> <span class="pre">Scope</span></code> and <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> indexed by
<code class="docutils literal notranslate"><span class="pre">Phase</span></code> that holds <code class="docutils literal notranslate"><span class="pre">Set</span> <span class="pre">Scope</span></code>. Furthermore, both <code class="docutils literal notranslate"><span class="pre">Scope</span></code> and <code class="docutils literal notranslate"><span class="pre">Phase</span></code>
are Integer-like. So we have an implementation that could use <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> and
<code class="docutils literal notranslate"><span class="pre">IntSet</span></code> instead of <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> and <code class="docutils literal notranslate"><span class="pre">Data.Set</span></code>.</p>
<p>We know that <code class="docutils literal notranslate"><span class="pre">isSubsetOf</span></code> does a lot of allocation. Now we can see where this
allocation is happening. <code class="docutils literal notranslate"><span class="pre">isSubsetOf</span></code> checks that <code class="docutils literal notranslate"><span class="pre">scs1</span></code> is a subset of
<code class="docutils literal notranslate"><span class="pre">scs2</span></code> by calling <code class="docutils literal notranslate"><span class="pre">Set.isSubsetOf</span></code> on the result of the <code class="docutils literal notranslate"><span class="pre">scopes</span></code> function.
<code class="docutils literal notranslate"><span class="pre">scopes</span></code> is allocating a new <code class="docutils literal notranslate"><span class="pre">Set</span> <span class="pre">Scope</span></code> from the <code class="docutils literal notranslate"><span class="pre">ScopeSet</span></code> via
<code class="docutils literal notranslate"><span class="pre">Set.union</span></code>, then using the results of a lookup on the <code class="docutils literal notranslate"><span class="pre">phaseScopes</span></code> Map,
then merging two <code class="docutils literal notranslate"><span class="pre">Set</span></code>’s just to check the subset.</p>
<p>There are several ways to improve the memory performance of this function.
First, we can employ better data structures. We know that this code is
performing a lot of merges, so we should expect an improvement in both time and
memory performance by using an <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> and <code class="docutils literal notranslate"><span class="pre">IntSet</span></code> because these data
structures provide more efficient merges than <code class="docutils literal notranslate"><span class="pre">Data.Set</span></code> and <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>.
Second, we can use a better algorithm. From the ticky, <code class="docutils literal notranslate"><span class="pre">isSubSetOf</span></code> was called
61143424 times. As written, this code will perform its lookups and unions <em>each</em>
time, even if we have a duplicate call. So this seems to be a good candidate for
memoization or caching the calls to <code class="docutils literal notranslate"><span class="pre">isSubsetOf</span></code>. We could also avoid building
the intermediate <code class="docutils literal notranslate"><span class="pre">Set</span></code> in the <code class="docutils literal notranslate"><span class="pre">scopes</span></code> function by checking for a subset
without merging <code class="docutils literal notranslate"><span class="pre">universalScopes</span></code> and <code class="docutils literal notranslate"><span class="pre">phaseScopes</span></code>.</p>
<p>The second interesting function was <code class="docutils literal notranslate"><span class="pre">unionWith</span></code> in the <code class="docutils literal notranslate"><span class="pre">Monoid</span> <span class="pre">Binding</span></code>
instance. Here is the source code:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">BindingTable</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">BindingTable</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_bindings</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="kt">Text</span><span class="w"> </span><span class="p">[(</span><span class="kt">ScopeSet</span><span class="p">,</span><span class="w"> </span><span class="kt">Binding</span><span class="p">,</span><span class="w"> </span><span class="kt">BindingInfo</span><span class="w"> </span><span class="kt">SrcLoc</span><span class="p">)]</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Semigroup</span><span class="w"> </span><span class="kt">BindingTable</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">b1</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">BindingTable</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">unionWith</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="n">bindings</span><span class="w"> </span><span class="n">b1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="n">bindings</span><span class="w"> </span><span class="n">b2</span><span class="p">)</span><span class="w"></span>

<span class="kr">instance</span><span class="w"> </span><span class="kt">Monoid</span><span class="w"> </span><span class="kt">BindingTable</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">mempty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">BindingTable</span><span class="w"> </span><span class="kt">Map</span><span class="o">.</span><span class="n">empty</span><span class="w"></span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">BindingTable</span></code> is a <code class="docutils literal notranslate"><span class="pre">Map</span></code> keyed on <code class="docutils literal notranslate"><span class="pre">Text</span></code> that holds a list of triples.
The <code class="docutils literal notranslate"><span class="pre">Semigroup</span></code> instance is the origin of the <code class="docutils literal notranslate"><span class="pre">unionWith</span></code> in the ticky
profile because <code class="docutils literal notranslate"><span class="pre">Monoid.mappend</span></code> defaults to the Semigroup definition. This
type is likely too lazy. <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> keyed on <code class="docutils literal notranslate"><span class="pre">Text</span></code> relies on the <code class="docutils literal notranslate"><span class="pre">Ord</span></code>
and <code class="docutils literal notranslate"><span class="pre">Eq</span></code> instances of <code class="docutils literal notranslate"><span class="pre">Text</span></code> for most of its operations. In the worst case
this means the runtime system has to compare the entire <code class="docutils literal notranslate"><span class="pre">Text</span></code> key, which
could be slow when the <code class="docutils literal notranslate"><span class="pre">Text</span></code> is large. Another problem is the use of a list.
A list is only an appropriate data structure if it is used like a stack or if it
is used as a store that is eventually traversed and consumed. Once one finds
themselves performing lookups or merges on a list, it is time to use a different
data structure. The last problem is the 3-tuple which we have already covered
above.</p>
<p>To improve the performance of the <code class="docutils literal notranslate"><span class="pre">BindingTable</span></code> we’ll use a <code class="docutils literal notranslate"><span class="pre">HashMap</span></code>. This
should yield better merge performance, and faster writes and reads. However,
this may not fix the root cause of the allocations. So we’ll rerun the ticky
report after making the changes to test that we have indeed addressed the
problem.</p>
</section>
<section id="optimization-1-better-data-structures-maps">
<h2><span class="section-number">4.3.5. </span>Optimization 1: Better Data Structures: Maps<a class="headerlink" href="#optimization-1-better-data-structures-maps" title="Permalink to this heading">¶</a></h2>
<p>We’ve removed all uses of <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> and replaced them with either a
<code class="docutils literal notranslate"><span class="pre">HashMap</span></code> or an <code class="docutils literal notranslate"><span class="pre">IntMap</span></code>. After the changes <code class="docutils literal notranslate"><span class="pre">ExpanderState</span></code> now looks
like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">ExpanderState</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">ExpanderState</span><span class="w"></span>
<span class="p">{</span><span class="w"> </span><span class="n">_expanderWorld</span><span class="w">              </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">World</span><span class="w"> </span><span class="kt">Value</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderNextScopeNum</span><span class="w">       </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Int</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderGlobalBindingTable</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">BindingTable</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderExpansionEnv</span><span class="w">       </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">ExpansionEnv</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderTasks</span><span class="w">              </span><span class="ow">::</span><span class="w"> </span><span class="p">[(</span><span class="kt">TaskID</span><span class="p">,</span><span class="w"> </span><span class="kt">ExpanderLocal</span><span class="p">,</span><span class="w"> </span><span class="kt">ExpanderTask</span><span class="p">)]</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderOriginLocations</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">SplitCorePtr</span><span class="w"> </span><span class="kt">SrcLoc</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedCore</span><span class="w">      </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">SplitCorePtr</span><span class="w"> </span><span class="p">(</span><span class="kt">CoreF</span><span class="w"> </span><span class="kt">TypePatternPtr</span><span class="w"> </span><span class="kt">PatternPtr</span><span class="w"> </span><span class="kt">SplitCorePtr</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedPatterns</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">PatternPtr</span><span class="w"> </span><span class="p">(</span><span class="kt">ConstructorPatternF</span><span class="w"> </span><span class="kt">PatternPtr</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedTypePatterns</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">TypePatternPtr</span><span class="w"> </span><span class="kt">TypePattern</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderPatternBinders</span><span class="w">     </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">PatternPtr</span><span class="w"> </span><span class="p">(</span><span class="kt">Either</span><span class="w"> </span><span class="p">[</span><span class="kt">PatternPtr</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="kt">Scope</span><span class="p">,</span><span class="w"> </span><span class="kt">Ident</span><span class="p">,</span><span class="w"> </span><span class="kt">Var</span><span class="p">,</span><span class="w"> </span><span class="kt">SchemePtr</span><span class="p">)))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderTypePatternBinders</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">TypePatternPtr</span><span class="w"> </span><span class="p">[(</span><span class="kt">Scope</span><span class="p">,</span><span class="w"> </span><span class="kt">Ident</span><span class="p">,</span><span class="w"> </span><span class="kt">Var</span><span class="p">,</span><span class="w"> </span><span class="kt">SchemePtr</span><span class="p">)])</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedTypes</span><span class="w">     </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">SplitTypePtr</span><span class="w"> </span><span class="p">(</span><span class="kt">TyF</span><span class="w"> </span><span class="kt">SplitTypePtr</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedDeclTrees</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">DeclTreePtr</span><span class="w"> </span><span class="p">(</span><span class="kt">DeclTreeF</span><span class="w"> </span><span class="kt">DeclPtr</span><span class="w"> </span><span class="kt">DeclTreePtr</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedDecls</span><span class="w">     </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">DeclPtr</span><span class="w"> </span><span class="p">(</span><span class="kt">Decl</span><span class="w"> </span><span class="kt">SplitTypePtr</span><span class="w"> </span><span class="kt">SchemePtr</span><span class="w"> </span><span class="kt">DeclTreePtr</span><span class="w"> </span><span class="kt">SplitCorePtr</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderModuleTop</span><span class="w">          </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">DeclTreePtr</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderModuleImports</span><span class="w">      </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Imports</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderModuleExports</span><span class="w">      </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Exports</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderPhaseRoots</span><span class="w">         </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="kt">Scope</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderModuleRoots</span><span class="w">        </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">HashMap</span><span class="w"> </span><span class="kt">ModuleName</span><span class="w"> </span><span class="kt">Scope</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderKernelBindings</span><span class="w">     </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">BindingTable</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderKernelExports</span><span class="w">      </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Exports</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderKernelDatatypes</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">HashMap</span><span class="w"> </span><span class="kt">Datatype</span><span class="w"> </span><span class="kt">DatatypeInfo</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderKernelConstructors</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">HashMap</span><span class="w"> </span><span class="kt">Constructor</span><span class="w"> </span><span class="p">(</span><span class="kt">ConstructorInfo</span><span class="w"> </span><span class="kt">Ty</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderKernelValues</span><span class="w">       </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Env</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="p">(</span><span class="kt">SchemePtr</span><span class="p">,</span><span class="w"> </span><span class="kt">Value</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderDeclOutputScopes</span><span class="w">   </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">DeclOutputScopesPtr</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCurrentEnvs</span><span class="w">        </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">Env</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="kt">Value</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCurrentTransformerEnvs</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">Env</span><span class="w"> </span><span class="kt">MacroVar</span><span class="w"> </span><span class="kt">Value</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCurrentDatatypes</span><span class="w">   </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">HashMap</span><span class="w"> </span><span class="kt">Datatype</span><span class="w"> </span><span class="kt">DatatypeInfo</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCurrentConstructors</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">HashMap</span><span class="w"> </span><span class="kt">Constructor</span><span class="w"> </span><span class="p">(</span><span class="kt">ConstructorInfo</span><span class="w"> </span><span class="kt">Ty</span><span class="p">)))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCurrentBindingTable</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">BindingTable</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderExpressionTypes</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">SplitCorePtr</span><span class="w"> </span><span class="kt">Ty</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderCompletedSchemes</span><span class="w">   </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">SchemePtr</span><span class="w"> </span><span class="p">(</span><span class="kt">Scheme</span><span class="w"> </span><span class="kt">Ty</span><span class="p">))</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderTypeStore</span><span class="w">          </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">TypeStore</span><span class="w"> </span><span class="kt">Ty</span><span class="p">)</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderKindStore</span><span class="w">          </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">KindStore</span><span class="w"></span>
<span class="p">,</span><span class="w"> </span><span class="n">_expanderDefTypes</span><span class="w">           </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">TypeContext</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="kt">SchemePtr</span><span class="p">)</span><span class="w"> </span><span class="c1">-- ^ Module-level definitions</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>where a <code class="docutils literal notranslate"><span class="pre">Store</span> <span class="pre">k</span> <span class="pre">v</span></code> is newtype over an <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> with some type level
handling for keys:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- new module Util.Store</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">Store</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Store</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">unStore</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IntMap</span><span class="w"> </span><span class="n">v</span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="kr">newtype</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Semigroup</span><span class="p">,</span><span class="w"> </span><span class="kt">Monoid</span><span class="p">,</span><span class="w"> </span><span class="kt">Functor</span><span class="p">,</span><span class="w"> </span><span class="kt">Foldable</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="n">stock</span><span class="w">   </span><span class="kt">Data</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="kt">Store</span><span class="w"> </span><span class="n">representational</span><span class="w"> </span><span class="kr">_</span><span class="w"></span>

<span class="c1">-- | Tiny module to wrap operations for IntMaps</span><span class="w"></span>

<span class="kr">module</span><span class="w"> </span><span class="nn">Util.Key</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="kt">HasKey</span><span class="p">(</span><span class="o">..</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>

<span class="kr">class</span><span class="w"> </span><span class="kt">HasKey</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">  </span><span class="n">getKey</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="w">  </span><span class="n">fromKey</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">HasKey</span></code> class is crucial for preserving type safety so that we do not
accidentally merge a <code class="docutils literal notranslate"><span class="pre">Store</span> <span class="pre">k</span> <span class="pre">v</span></code> and a <code class="docutils literal notranslate"><span class="pre">Store</span> <span class="pre">p</span> <span class="pre">v</span></code> when <code class="docutils literal notranslate"><span class="pre">p</span></code> is not equal
to <code class="docutils literal notranslate"><span class="pre">k</span></code>. It also allows us to provide functions such as <code class="docutils literal notranslate"><span class="pre">mapKeys</span></code> with a
polymorphic type on the <code class="docutils literal notranslate"><span class="pre">Key</span></code>, as opposed to the monomorphic type in
<code class="docutils literal notranslate"><span class="pre">Data.IntMap</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mapKeys</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">HasKey</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Store</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Store</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="nf">mapKeys</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Store</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="kt">IM</span><span class="o">.</span><span class="n">mapKeys</span><span class="w"> </span><span class="p">(</span><span class="n">getKey</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">fromKey</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">unStore</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>I’ve purposefully taken the opportunity to create the abstraction boundary
<code class="docutils literal notranslate"><span class="pre">Store</span> <span class="pre">p</span> <span class="pre">v</span></code>, which is unnecessary from a performance perspective. But by
having an abstraction boundary the system becomes easier to change. For
example, we can now alter the implementation of <code class="docutils literal notranslate"><span class="pre">Store</span> <span class="pre">p</span> <span class="pre">v</span></code> <em>without</em> a lot
of code churn occurring in the interpreter. The key point is that if a
subsystem is easy to change, then it is also easy to experiment and engineer,
because the cost of experimentation is reduced. So while performance and
modularity are often in tension, in this case, modularity enables easier and
cheaper (in terms of engineering time) performance engineering.</p>
</div>
<p>now let’s check the ticky:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat ticky | tail -n +20 | sort -k2 -nr | less

  53996388 4319711040          0   3 +.&gt;                  ScopeSet.$wallScopeSets&#39;{v rP2F} (fun)
  60490404 3871385856 2159855520   3 +..                  sat_sQ5D{v} (ScopeSet) (fun) in rP2F
  20257037 1487236040          0   3 iMM                  Binding.$wgo{v r1ric} (fun)
  81547057 1368797696          0   4 SISM                 ScopeSet.$w$sgo4{v rP2E} (fun)
  57730804 1305110352          0   4 SISM                 ScopeSet.$w$sgo1{v rP2D} (fun)
    867831  366262720          0  10 piiSiSL&gt;&gt;&gt;           Parser.Common.$wg{v r3zJ} (fun)
    886661  333384536          0   6 SS&gt;&gt;&gt;&gt;               located{v r1art} (Parser) (fun)
  10521949  330656896          0   3 Lii                  ModuleName.$wgo1{v roEi} (fun)
   4552387  298031744          0   3 ISM                  Expander.$w$sgo4{v r5On7} (fun)
   2699373  259139808          0   4 &gt;SSM                 Syntax.$w$cmapScopes{v rUeh} (fun)
   1351616  237884416     612288   1 T                    f{v s1sRr} (Binding) (fun) in r1rif
   3159635  193376496    1071504   1 M                    go{v s1sS8} (Binding) (fun) in r1rif
   2348710  169685264    1156288   1 M                    go2{v s16Wz} (Env) (fun) in r16zL
   4590545  146897440  183644160   0                      f2{v s1t5Z} (Binding) (thk) in r1ric
    101588  145802400          0   4 MSSM                 $wexpandOneForm{v r5VBM} (Expander) (fun)
   2607448  125157504          0   2 &gt;S                   Syntax.$fHasScopesSyntax_$cmapScopes{v rUeg} (fun)
   1357729  119480152     486976   1 S                    sat_s5YKN{v} (Expander) (fun) in s5YKB
    144974  118076280          0  10 piiiSL&gt;&gt;&gt;&gt;           $wm2{v r1arF} (Parser) (fun)
</pre></div>
</div>
<p>Notice that the entries to <code class="docutils literal notranslate"><span class="pre">unionWith</span></code> and <code class="docutils literal notranslate"><span class="pre">isSubsetOf</span></code> have disappeared.
<code class="docutils literal notranslate"><span class="pre">isSubsetOf</span></code> is still in the ticky report but is now shown as non-allocating:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">...</span>
<span class="go">38279681          0          0   2 MM                   ScopeSet.$sisSubsetOf_$sisSubsetOfX{v rP2u} (fun)</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Which is strange. We should expect it to be allocating, although allocating a
lot less. We are likely observing some new optimization GHC is applying. In any
case, its a good sign. We’ve demonstrated progress with the ticky report. Now
let’s verify that these changes propagate to the <code class="docutils literal notranslate"><span class="pre">implicit-conversion</span></code> test.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Test suite klister-tests: RUNNING...</span>
<span class="go">All tests</span>
<span class="go">  Expander tests</span>
<span class="go">  ...</span>
<span class="go">    Module tests</span>
<span class="go">      Expected to succeed</span>
<span class="go">      ...</span>
<span class="go">        examples/lang.kl:                              OK (0.04s)</span>
<span class="go">        examples/import.kl:                            OK (0.03s)</span>
<span class="go">        examples/macro-body-shift.kl:                  OK (0.04s)</span>
<span class="go">        examples/test-quasiquote.kl:                   OK (0.04s)</span>
<span class="go">        examples/quasiquote-syntax-test.kl:            OK (0.03s)</span>
<span class="go">        examples/hygiene.kl:                           OK (0.66s)</span>
<span class="go">        examples/defun-test.kl:                        OK (0.03s)</span>
<span class="go">        examples/fun-exports-test.kl:                  OK (0.04s)</span>
<span class="go">  Golden tests</span>
<span class="go">    test-quasiquote:                                   OK (0.04s)</span>
<span class="go">    io:                                                OK (0.03s)</span>
<span class="go">    defun-test:                                        OK (0.03s)</span>
<span class="go">    contract:                                          OK (0.08s)</span>
<span class="go">    int-ops:                                           OK (0.05s)</span>
<span class="go">    implicit-conversion:                               OK (10.42s)</span>
<span class="go">    ...</span>
<span class="go">    implicit-conversion-test:                          OK (13.55s)</span>
<span class="go">    higher-kinded-patterns:                            OK (0.77s)</span>
<span class="go">    custom-literals-test:                              OK (0.38s)</span>
<span class="go">    double-define:                                     OK (0.28s)</span>
<span class="go">    custom-module-test:                                OK (0.33s)</span>
<span class="go">    which-problem:                                     OK (0.53s)</span>
<span class="go">    incorrect-context:                                 OK (0.03s)</span>
<span class="go">    bound-vs-free:                                     OK (0.25s)</span>
<span class="go">    meta-macro:                                        OK (0.10s)</span>
<span class="go">    integer-syntax:                                    OK (0.04s)</span>
<span class="go">    import:                                            OK (0.03s)</span>
</pre></div>
</div>
<p>Performance has degraded even though the ticky report showed an improvement!
That we do not observe any difference in wall time <em>after</em> fixing the 5th and
6th most allocating function calls is contrary to what we should expect; even if
the total allocations of these functions are one order of magnitude less than
<code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code>. The <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> performance costs must have been eclipsed by
some other issue. Let’s generate a heap profile to see what’s going on in the
heap.</p>
</section>
<section id="optimization-2-a-memory-leak-casts-a-long-shadow">
<h2><span class="section-number">4.3.6. </span>Optimization 2: A Memory Leak Casts a Long Shadow<a class="headerlink" href="#optimization-2-a-memory-leak-casts-a-long-shadow" title="Permalink to this heading">¶</a></h2>
<p>To continue engineering the interpreter we need to be able to observe the
effects of any change we make. Unfortunately, the memory leak we discovered in
the last section was so large it eclipsed the effect of our changes. Clearly we
need to fix this leak in order to continue to optimize. To tackle this memory
leak, we’ll use eventlog and eventlog2html to observe the heap only on
<code class="docutils literal notranslate"><span class="pre">implicit-conversion-test</span></code>. To begin we’ll inspect the types that were
allocated on the heap by passing <code class="docutils literal notranslate"><span class="pre">-hy</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cabal <span class="nb">test</span> --test-show-details<span class="o">=</span>streaming  --test-options<span class="o">=</span><span class="s1">&#39;--pattern &quot;implicit-conversion-test&quot; +RTS -hy -l-agu -p -RTS&#39;</span> --ghc-options<span class="o">=</span><span class="s1">&#39;-eventlog -rtsopts -O2&#39;</span>
</pre></div>
</div>
<p>which produces:</p>
<iframe id="scaled-frame" scrolling="no" src="/_static/klister/klister-eventlog-implicit-conversion-hy.html"></iframe><p>We see that the heap is growing to over 2.8Gb of lists for just one test!
Crucially the shape of this profile is not indicative of a memory leak. A
typical memory leak should look like a pyramid because the program builds up
thunks and then forces them all in relatively short time. What we observe in
this profile is allocations of lists that <em>never decrease</em>. Now that we know the
type to look for, we can correlate this type to a subsystem in the interpreter.
To do so we’ll run another heap profile, but break down the heap by module (by
using <code class="docutils literal notranslate"><span class="pre">-hm</span></code> instead of <code class="docutils literal notranslate"><span class="pre">-hy</span></code>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cabal <span class="nb">test</span> --test-show-details<span class="o">=</span>streaming  --test-options<span class="o">=</span><span class="s1">&#39;--pattern &quot;implicit-conversion-test&quot; +RTS -hm -l-agu -p -RTS&#39;</span> --ghc-options<span class="o">=</span><span class="s1">&#39;-eventlog -rtsopts -O2&#39;</span>
</pre></div>
</div>
<iframe id="scaled-frame" scrolling="no" src="/_static/klister/klister-eventlog-implicit-conversion-hm.html"></iframe><p>We see that these lists are coming from <code class="docutils literal notranslate"><span class="pre">Expander.Monad</span></code>. This is suspicious.
We have data being consistently allocated in essentially the state type of a
subsystem. That certainly sounds like a memory leak. Before we can conclude that
the expander has a memory leak we need to know why this data is retained at all.
This is a good scenario to use <a class="reference external" href="https://downloads.haskell.org/~ghc/9.2.4/docs/html/users_guide/profiling.html#biographical-profiling">Biographical Profiling</a> because we want to know: (1) the state
of these objects on the heap and (2) why they are not being collected, that is,
why is GHC’s runtime system keeping them alive. For (1) we’ll do a biographical
profile and for (2) a retainer profile.</p>
<p>Here’s the biographical profile:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cabal <span class="nb">test</span> --test-show-details<span class="o">=</span>streaming  --test-options<span class="o">=</span><span class="s1">&#39;--pattern &quot;implicit-conversion-test&quot; +RTS -hb -l-agu -p -RTS&#39;</span> --ghc-options<span class="o">=</span><span class="s1">&#39;-eventlog -rtsopts -O2&#39;</span>
</pre></div>
</div>
<iframe id="scaled-frame" scrolling="no" src="/_static/klister/klister-eventlog-implicit-conversion-hb.html"></iframe><p>Void! The lists are in a <code class="docutils literal notranslate"><span class="pre">void</span></code> state meaning these objects are allocated <em>but
are never used</em> (see <a class="reference external" href="https://downloads.haskell.org/~ghc/9.2.4/docs/html/users_guide/profiling.html#biographical-profiling">the user guide</a>). Now we can restate the problem: There
is a memory leak in the <code class="docutils literal notranslate"><span class="pre">Expander</span></code>. When <code class="docutils literal notranslate"><span class="pre">implicit-conversion-test</span></code> is run,
the expander allocates a total of 121.8 Gb. (eventlog shows 116171.68
<em>MebiBytes</em> in the detailed tab).</p>
<p>Now to answer why this data is being retained. Here is the retainer profile.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cabal <span class="nb">test</span> --enable-profiling --test-show-details<span class="o">=</span>streaming --test-options<span class="o">=</span><span class="s1">&#39;--pattern &quot;implicit-conversion-test&quot; +RTS -hr -l-agu -p -RTS&#39;</span> --ghc-options<span class="o">=</span><span class="s1">&#39;-eventlog -rtsopts -O2&#39;</span>
<span class="gp">$ </span>hp2ps -c klister-tests.hp <span class="o">&amp;&amp;</span> ps2pdf klister-tests.ps
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Eventlog threw an exception for this retainer profile. So I’ve resorted to
use the classic tools: <code class="docutils literal notranslate"><span class="pre">hp2ps</span></code> and <code class="docutils literal notranslate"><span class="pre">ps2pdf</span></code> to render the profile.</p>
</div>
<a class="reference internal image-reference" href="../../_images/klister-eventlog-implicit-conversion-hr.png"><img alt="../../_images/klister-eventlog-implicit-conversion-hr.png" src="../../_images/klister-eventlog-implicit-conversion-hr.png" style="width: 800px;" /></a>
<p>The retainer profile clearly shows that <code class="docutils literal notranslate"><span class="pre">currentEnv</span></code> is keeping this data
alive and has the distinguishing profile of a memory leak. Let’s look at that
function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- in Expander.Monad</span><span class="w"></span>

<span class="nf">currentEnv</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="kt">VEnv</span><span class="w"></span>
<span class="nf">currentEnv</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">phase</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"></span>
<span class="w">  </span><span class="n">globalEnv</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fromMaybe</span><span class="w"> </span><span class="n">mempty</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="p">(</span><span class="n">expanderWorld</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">worldEnvironments</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">phase</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getState</span><span class="w"></span>
<span class="w">  </span><span class="n">localEnv</span><span class="w">  </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fromMaybe</span><span class="w"> </span><span class="n">mempty</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="p">(</span><span class="n">expanderCurrentEnvs</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">phase</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getState</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">globalEnv</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">localEnv</span><span class="w"></span>
</pre></div>
</div>
<p>This code is reading from the <code class="docutils literal notranslate"><span class="pre">Expander</span></code> state twice to retrieve <code class="docutils literal notranslate"><span class="pre">globalEnv</span></code>
and <code class="docutils literal notranslate"><span class="pre">localEnv</span></code>, and then returning the union of these two environments. Notice
that if the results of <code class="docutils literal notranslate"><span class="pre">currentEnv</span></code> are not immediately forced, then the
projections and the return will be lazy. Thus, this code will allocate a thunk
for <code class="docutils literal notranslate"><span class="pre">phase</span></code>, <code class="docutils literal notranslate"><span class="pre">globalEnv</span></code>, <code class="docutils literal notranslate"><span class="pre">localEnv</span></code> and the merge of both <code class="docutils literal notranslate"><span class="pre">globalEnv</span></code>
and <code class="docutils literal notranslate"><span class="pre">localEnv</span></code>. In general, unless the result of a monadic action <em>needs</em> to
be consumed lazily there is little reason to not make it strict in the return.
In this case, there are two call sites to <code class="docutils literal notranslate"><span class="pre">currentEnv</span></code> both in the expander:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Expander.hs</span><span class="w"></span>
<span class="nf">runTask</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">TaskID</span><span class="p">,</span><span class="w"> </span><span class="kt">ExpanderLocal</span><span class="p">,</span><span class="w"> </span><span class="kt">ExpanderTask</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">runTask</span><span class="w"> </span><span class="p">(</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="n">localData</span><span class="p">,</span><span class="w"> </span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">withLocal</span><span class="w"> </span><span class="n">localData</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
<span class="w"> </span><span class="kt">AwaitingDefn</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">defn</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">dest</span><span class="w"> </span><span class="n">stx</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">   </span><span class="kt">Env</span><span class="o">.</span><span class="n">lookupVal</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">currentEnv</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"></span>
<span class="w">   </span><span class="nf">\</span><span class="kr">case</span><span class="w"></span>


<span class="nf">evalDecl</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">CompleteDecl</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">WriterT</span><span class="w"> </span><span class="p">[</span><span class="kt">EvalResult</span><span class="p">]</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">evalDecl</span><span class="w"> </span><span class="p">(</span><span class="kt">CompleteDecl</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">  </span><span class="o">...</span><span class="w"></span>
<span class="w">  </span><span class="kt">Example</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">sch</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">   </span><span class="n">env</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">lift</span><span class="w"> </span><span class="n">currentEnv</span><span class="w"></span>
<span class="w">   </span><span class="n">value</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">lift</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">expandEval</span><span class="w"> </span><span class="p">(</span><span class="n">eval</span><span class="w"> </span><span class="n">expr</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">tell</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">[</span><span class="kt">ExampleResult</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="n">sch</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>The first call site in <code class="docutils literal notranslate"><span class="pre">runTask</span></code> is immediately scrutinized by the <code class="docutils literal notranslate"><span class="pre">\case</span></code>
and <code class="docutils literal notranslate"><span class="pre">Env.lookupVal</span></code>. However, the second is not: <code class="docutils literal notranslate"><span class="pre">ExampleResult</span></code> is not
strict in any fields:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">EvalResult</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">ExampleResult</span><span class="w"> </span><span class="kt">SrcLoc</span><span class="w"> </span><span class="kt">VEnv</span><span class="w"> </span><span class="kt">Core</span><span class="w"> </span><span class="p">(</span><span class="kt">Scheme</span><span class="w"> </span><span class="kt">Ty</span><span class="p">)</span><span class="w"> </span><span class="kt">Value</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">IOResult</span><span class="w"> </span><span class="p">(</span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>and the whole computation is performed in a lazy <code class="docutils literal notranslate"><span class="pre">WriterT</span></code> monad transformer.
Before changing the code, let’s first inspect the type of the <code class="docutils literal notranslate"><span class="pre">Expand</span></code> monad.
Here is the definition for <code class="docutils literal notranslate"><span class="pre">Expand</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Expand</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">runExpand</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ReaderT</span><span class="w"> </span><span class="kt">ExpanderContext</span><span class="w"> </span><span class="p">(</span><span class="kt">ExceptT</span><span class="w"> </span><span class="kt">ExpansionErr</span><span class="w"> </span><span class="kt">IO</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Functor</span><span class="p">,</span><span class="w"> </span><span class="kt">Applicative</span><span class="p">,</span><span class="w"> </span><span class="kt">Monad</span><span class="p">,</span><span class="w"> </span><span class="kt">MonadError</span><span class="w"> </span><span class="kt">ExpansionErr</span><span class="p">,</span><span class="w"> </span><span class="kt">MonadIO</span><span class="p">,</span><span class="w"> </span><span class="kt">MonadReader</span><span class="w"> </span><span class="kt">ExpanderContext</span><span class="p">)</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">ExpanderContext</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">ExpanderContext</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">_expanderLocal</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">ExpanderLocal</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_expanderState</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IORef</span><span class="w"> </span><span class="kt">ExpanderState</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">ExpanderState</span></code> was shown above. So we have a classic <a class="reference external" href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern/">ReaderT over IO</a> pattern.
Meaning that the laziness of any state updates depend on the strictness of
functions operating on <code class="docutils literal notranslate"><span class="pre">ExpanderContext</span></code>. Next let’s check the types of
<code class="docutils literal notranslate"><span class="pre">globalEnv</span></code> and <code class="docutils literal notranslate"><span class="pre">localEnv</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- in Expander.Monad.hs</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="kt">VEnv</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Env</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="kt">Value</span><span class="w"></span>

<span class="c1">-- in Env.hs</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">Env</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Env</span><span class="w"> </span><span class="p">(</span><span class="kt">IntMap</span><span class="w"> </span><span class="p">(</span><span class="kt">Ident</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="kr">newtype</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Monoid</span><span class="p">,</span><span class="w"> </span><span class="kt">Semigroup</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="n">stock</span><span class="w"> </span><span class="kt">Functor</span><span class="w"></span>

<span class="c1">-- in World.hs</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">World</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">World</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">_worldEnvironments</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">Env</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_worldTypeContexts</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">TypeContext</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="kt">SchemePtr</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_worldTransformerEnvironments</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">Env</span><span class="w"> </span><span class="kt">MacroVar</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_worldModules</span><span class="w">      </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">HashMap</span><span class="w"> </span><span class="kt">ModuleName</span><span class="w"> </span><span class="kt">CompleteModule</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_worldVisited</span><span class="w">      </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">HashMap</span><span class="w"> </span><span class="kt">ModuleName</span><span class="w"> </span><span class="p">(</span><span class="kt">Set</span><span class="w"> </span><span class="kt">Phase</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_worldExports</span><span class="w">      </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">HashMap</span><span class="w"> </span><span class="kt">ModuleName</span><span class="w"> </span><span class="kt">Exports</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_worldEvaluated</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">HashMap</span><span class="w"> </span><span class="kt">ModuleName</span><span class="w"> </span><span class="p">[</span><span class="kt">EvalResult</span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_worldDatatypes</span><span class="w">    </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">HashMap</span><span class="w"> </span><span class="kt">Datatype</span><span class="w"> </span><span class="kt">DatatypeInfo</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_worldConstructors</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Store</span><span class="w"> </span><span class="kt">Phase</span><span class="w"> </span><span class="p">(</span><span class="kt">HashMap</span><span class="w"> </span><span class="kt">Constructor</span><span class="w"> </span><span class="p">(</span><span class="kt">ConstructorInfo</span><span class="w"> </span><span class="kt">Ty</span><span class="p">)))</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_worldLocation</span><span class="w">     </span><span class="ow">::</span><span class="w"> </span><span class="kt">FilePath</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">currentEnv</span></code> returns a <code class="docutils literal notranslate"><span class="pre">Expand</span> <span class="pre">VEnv</span></code>, <code class="docutils literal notranslate"><span class="pre">VEnv</span></code> is a <code class="docutils literal notranslate"><span class="pre">Env</span> <span class="pre">Var</span> <span class="pre">Value</span></code> where
an <code class="docutils literal notranslate"><span class="pre">Env</span></code> is an <code class="docutils literal notranslate"><span class="pre">IntMap</span></code>. Thus <code class="docutils literal notranslate"><span class="pre">globalEnv</span></code> and <code class="docutils literal notranslate"><span class="pre">localEnv</span></code> are both a
strict <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> that stores a tuple of <code class="docutils literal notranslate"><span class="pre">(Ident,</span> <span class="pre">Value)</span></code>. Here is the type of
<code class="docutils literal notranslate"><span class="pre">Value</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- in Value.hs</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Value</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">ValueClosure</span><span class="w"> </span><span class="kt">Closure</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueSyntax</span><span class="w"> </span><span class="kt">Syntax</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueMacroAction</span><span class="w"> </span><span class="kt">MacroAction</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueIOAction</span><span class="w"> </span><span class="p">(</span><span class="kt">IO</span><span class="w"> </span><span class="kt">Value</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueOutputPort</span><span class="w"> </span><span class="kt">Handle</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueInteger</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueCtor</span><span class="w"> </span><span class="kt">Constructor</span><span class="w"> </span><span class="p">[</span><span class="kt">Value</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueType</span><span class="w"> </span><span class="kt">Ty</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueString</span><span class="w"> </span><span class="kt">Text</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that <code class="docutils literal notranslate"><span class="pre">ValueCtor</span></code> holds a lazy list of <code class="docutils literal notranslate"><span class="pre">Value</span></code>. Should
<code class="docutils literal notranslate"><span class="pre">implicit-tests</span></code> create many <code class="docutils literal notranslate"><span class="pre">ValueCtor</span></code> then the expander state will leak
memory in <code class="docutils literal notranslate"><span class="pre">Value</span></code>. This leak will occur even though the <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> is strict.
The strict <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> well only evaluate elements to <a class="reference internal" href="../glossary.html#term-WHNF"><span class="xref std std-term">WHNF</span></a>, which will be
<code class="docutils literal notranslate"><span class="pre">(,)</span></code>, thus because <code class="docutils literal notranslate"><span class="pre">Value</span></code> is stored in a lazy tuple, the fields of the
tuple will be lazy unless they are carefully forced <em>before</em> insertion.</p>
<p>Let’s test this and make <code class="docutils literal notranslate"><span class="pre">Value</span></code> strict and then generate another
biographical profile to observe the change:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- in Value.hs</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Value</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">ValueClosure</span><span class="w"> </span><span class="o">!</span><span class="kt">Closure</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueSyntax</span><span class="w">  </span><span class="o">!</span><span class="kt">Syntax</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueMacroAction</span><span class="w"> </span><span class="o">!</span><span class="kt">MacroAction</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueIOAction</span><span class="w">   </span><span class="o">!</span><span class="p">(</span><span class="kt">IO</span><span class="w"> </span><span class="kt">Value</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueOutputPort</span><span class="w"> </span><span class="o">!</span><span class="kt">Handle</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueInteger</span><span class="w">    </span><span class="o">!</span><span class="kt">Integer</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueCtor</span><span class="w">    </span><span class="o">!</span><span class="kt">Constructor</span><span class="w"> </span><span class="o">!</span><span class="p">[</span><span class="kt">Value</span><span class="p">]</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueType</span><span class="w">    </span><span class="o">!</span><span class="kt">Ty</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">ValueString</span><span class="w">  </span><span class="o">!</span><span class="kt">Text</span><span class="w"></span>
</pre></div>
</div>
<iframe id="scaled-frame" scrolling="no"
src="/_static/klister/klister-eventlog-implicit-conversion-strict-value.html"></iframe><p>Unfortunately, the change made no difference. We’ll revert the change and try
making the monadic action strict in its return:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- in Expander.Monad</span><span class="w"></span>

<span class="nf">currentEnv</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="kt">VEnv</span><span class="w"></span>
<span class="nf">currentEnv</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">phase</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"></span>
<span class="w">  </span><span class="n">globalEnv</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fromMaybe</span><span class="w"> </span><span class="n">mempty</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="p">(</span><span class="n">expanderWorld</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">worldEnvironments</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">phase</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getState</span><span class="w"></span>
<span class="w">  </span><span class="n">localEnv</span><span class="w">  </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fromMaybe</span><span class="w"> </span><span class="n">mempty</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="p">(</span><span class="n">expanderCurrentEnvs</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">phase</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getState</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">globalEnv</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">localEnv</span><span class="w"></span>
</pre></div>
</div>
<p>Notice the strict application: <code class="docutils literal notranslate"><span class="pre">$!</span></code>. This change results in this profile:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cabal <span class="nb">test</span> --test-show-details<span class="o">=</span>streaming  --test-options<span class="o">=</span><span class="s1">&#39;--pattern &quot;implicit-conversion-test&quot; +RTS -hb -l-agu -p -RTS&#39;</span> --ghc-options<span class="o">=</span><span class="s1">&#39;-eventlog -rtsopts -O2&#39;</span>
</pre></div>
</div>
<iframe id="scaled-frame" scrolling="no" src="/_static/klister/klister-eventlog-implicit-conversion-currentEnv-fixed.html"></iframe><p>A significant improvement! Instead of 121.8 Gb the profile shows total
allocation of <code class="docutils literal notranslate"><span class="pre">void</span></code> of 4.62 Gb (4404.22 MiB in the detailed tab) which is a
30x reduction.</p>
</section>
<section id="optimization-3-choosing-better-data-structures-lists">
<h2><span class="section-number">4.3.7. </span>Optimization 3: Choosing Better Data Structures: Lists<a class="headerlink" href="#optimization-3-choosing-better-data-structures-lists" title="Permalink to this heading">¶</a></h2>
<p>We closed a major memory leak, and have made the implementation of the expander
more efficient, but there is yet more low hanging fruit. Consider this
definition of the <code class="docutils literal notranslate"><span class="pre">BindingTable</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span><span class="w"> </span><span class="kt">BindingTable</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">BindingTable</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_bindings</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">HashMap</span><span class="w"> </span><span class="kt">Text</span><span class="w"> </span><span class="p">[(</span><span class="kt">ScopeSet</span><span class="p">,</span><span class="w"> </span><span class="kt">Binding</span><span class="p">,</span><span class="w"> </span><span class="kt">BindingInfo</span><span class="w"> </span><span class="kt">SrcLoc</span><span class="p">)]</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">BindingTable</span></code> is a <code class="docutils literal notranslate"><span class="pre">HashMap</span></code> keyed on <code class="docutils literal notranslate"><span class="pre">Text</span></code> that holds a list of
3-tuples. Let’s observe how this list is used in the system:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">visibleBindings</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="kt">BindingTable</span><span class="w"></span>
<span class="nf">visibleBindings</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">globals</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="n">expanderGlobalBindingTable</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getState</span><span class="w"></span>
<span class="w">  </span><span class="n">locals</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="n">expanderCurrentBindingTable</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getState</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">globals</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">locals</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This <code class="docutils literal notranslate"><span class="pre">visibleBindings</span></code> function projects two <code class="docutils literal notranslate"><span class="pre">BindingTable</span></code>’s from the
<code class="docutils literal notranslate"><span class="pre">ExpanderState</span></code> and then merges them. This function is then called by
<code class="docutils literal notranslate"><span class="pre">resolve</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">resolve</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ident</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="kt">Binding</span><span class="w"></span>
<span class="nf">resolve</span><span class="w"> </span><span class="n">stx</span><span class="o">@</span><span class="p">(</span><span class="kt">Stx</span><span class="w"> </span><span class="n">scs</span><span class="w"> </span><span class="n">srcLoc</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"></span>
<span class="w">  </span><span class="n">bs</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">allMatchingBindings</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">scs</span><span class="w"></span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span><span class="n">bs</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">[]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">      </span><span class="n">throwError</span><span class="w"> </span><span class="p">(</span><span class="kt">Unknown</span><span class="w"> </span><span class="p">(</span><span class="kt">Stx</span><span class="w"> </span><span class="n">scs</span><span class="w"> </span><span class="n">srcLoc</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">candidates</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">      </span><span class="kr">let</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">maximumOn</span><span class="w"> </span><span class="p">(</span><span class="kt">ScopeSet</span><span class="o">.</span><span class="n">size</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">fst</span><span class="p">)</span><span class="w"> </span><span class="n">candidates</span><span class="w"></span>
<span class="w">      </span><span class="kr">in</span><span class="w"> </span><span class="n">checkUnambiguous</span><span class="w"> </span><span class="p">(</span><span class="n">fst</span><span class="w"> </span><span class="n">best</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="n">candidates</span><span class="p">)</span><span class="w"> </span><span class="n">stx</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"></span>
<span class="w">         </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">snd</span><span class="w"> </span><span class="n">best</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">resolve</span></code> the <code class="docutils literal notranslate"><span class="pre">BindingTable</span></code> is checked to be empty, if its not empty
then the table is traversed for the maximum by scopeset. Then the maximum
element and the rest of the scopesets are passed to <code class="docutils literal notranslate"><span class="pre">checkUnambiguous</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkUnambiguous</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">ScopeSet</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Ident</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
<span class="nf">checkUnambiguous</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="n">candidates</span><span class="w"> </span><span class="n">blame</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="kr">do</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"></span>
<span class="w">     </span><span class="kr">let</span><span class="w"> </span><span class="n">bestSize</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="o">.</span><span class="n">size</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">best</span><span class="w"></span>
<span class="w">     </span><span class="kr">let</span><span class="w"> </span><span class="n">candidateSizes</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="kt">ScopeSet</span><span class="o">.</span><span class="n">size</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">nub</span><span class="w"> </span><span class="n">candidates</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="kr">if</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="p">(</span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">==</span><span class="w"> </span><span class="n">bestSize</span><span class="p">)</span><span class="w"> </span><span class="n">candidateSizes</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">       </span><span class="kr">then</span><span class="w"> </span><span class="n">throwError</span><span class="w"> </span><span class="p">(</span><span class="kt">Ambiguous</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">blame</span><span class="w"> </span><span class="n">candidates</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="kr">else</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="nb">()</span><span class="w"></span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">checkUnambiguous</span></code> the <code class="docutils literal notranslate"><span class="pre">candidates</span></code> list is pruned of any duplicates,
filtered, and its length is calculated to determine an error state.</p>
<p>Finally, in the <code class="docutils literal notranslate"><span class="pre">visit</span></code> the <code class="docutils literal notranslate"><span class="pre">BindingTable</span></code> (<code class="docutils literal notranslate"><span class="pre">bs</span></code>) is projected from the
module being visited and then merged with the interpreter’s binding table:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">visit</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ModuleName</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="kt">Exports</span><span class="w"></span>
<span class="nf">visit</span><span class="w"> </span><span class="n">modName</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">bs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">getModuleBindings</span><span class="w"> </span><span class="n">m&#39;&#39;</span><span class="w"></span>
<span class="w">    </span><span class="n">modifyState</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">expanderGlobalBindingTable</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">bs</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">es</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="n">getModuleBindings</span><span class="w"> </span><span class="p">(</span><span class="kt">Expanded</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">bs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">bs</span><span class="w"></span>
<span class="w">        </span><span class="n">getModuleBindings</span><span class="w"> </span><span class="p">(</span><span class="kt">KernelModule</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mempty</span><span class="w"></span>
</pre></div>
</div>
<p>So from this code, the <code class="docutils literal notranslate"><span class="pre">BindingTable</span></code> data structure undergoes merges,
traversals such as <code class="docutils literal notranslate"><span class="pre">fmap</span></code> and <code class="docutils literal notranslate"><span class="pre">filter</span></code> and the length is calculated. We can
check how often these functions are used in the <code class="docutils literal notranslate"><span class="pre">prof</span></code> report we generated
with the last heap profile (using the <code class="docutils literal notranslate"><span class="pre">-p</span></code> RTS flag). <code class="docutils literal notranslate"><span class="pre">visibleBindings</span></code> and
<code class="docutils literal notranslate"><span class="pre">resolve</span></code> are entered more than 100,000 times, <code class="docutils literal notranslate"><span class="pre">checkUnambiguous</span></code> is entered
less than 20,000 times. Thus merging and sorting are more important than
duplicate element removal and calculating length. Based on this usage, we’ll
replace the list with a <code class="docutils literal notranslate"><span class="pre">Data.Sequence</span></code>, a <code class="docutils literal notranslate"><span class="pre">Data.Set</span></code> would also work and
would provide uniqueness by default, but <code class="docutils literal notranslate"><span class="pre">Data.Set</span></code> has slower merge behavior
compared to a <code class="docutils literal notranslate"><span class="pre">Data.Sequence</span></code> for many elements
(<span class="math notranslate nohighlight">\(\mathcal{O}(\log{(\min(n_{1},n_{2}))})\)</span>, compared to
<span class="math notranslate nohighlight">\(\mathcal{O}(m \log{\frac{n + 1}{m + 1}})\)</span>, where <span class="math notranslate nohighlight">\(m \le n\)</span>).</p>
<p><code class="docutils literal notranslate"><span class="pre">BindingTable</span></code> is not the only suspicious list. Consider this list in the
definition of <code class="docutils literal notranslate"><span class="pre">Module</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Module</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Module</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">_moduleName</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ModuleName</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_moduleImports</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Imports</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_moduleBody</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">_moduleExports</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="o">!</span><span class="kt">Exports</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="p">,</span><span class="w"> </span><span class="kt">Functor</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>

<span class="w"> </span><span class="kr">data</span><span class="w"> </span><span class="kt">CompleteModule</span><span class="w"></span>
<span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Expanded</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="kt">Module</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kt">CompleteDecl</span><span class="p">)</span><span class="w"> </span><span class="o">!</span><span class="kt">BindingTable</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="kt">KernelModule</span><span class="w"> </span><span class="o">!</span><span class="kt">Phase</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This list is passed to <code class="docutils literal notranslate"><span class="pre">Module</span></code> as a type argument. But is used in this code
in the expander monad:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getDeclGroup</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">DeclTreePtr</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="p">[</span><span class="kt">CompleteDecl</span><span class="p">]</span><span class="w"></span>
<span class="nf">getDeclGroup</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">view</span><span class="w"> </span><span class="p">(</span><span class="n">expanderCompletedDeclTrees</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getState</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"></span>
<span class="w">  </span><span class="nf">\</span><span class="kr">case</span><span class="w"></span>
<span class="w">    </span><span class="kt">Nothing</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">throwError</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">InternalError</span><span class="w"> </span><span class="s">&quot;Incomplete module after expansion&quot;</span><span class="w"></span>
<span class="w">    </span><span class="kt">Just</span><span class="w"> </span><span class="kt">DeclTreeLeaf</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">pure</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="w">    </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="kt">DeclTreeAtom</span><span class="w"> </span><span class="n">decl</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="kt">:[]</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getDecl</span><span class="w"> </span><span class="n">decl</span><span class="w"></span>
<span class="w">    </span><span class="kt">Just</span><span class="w"> </span><span class="p">(</span><span class="kt">DeclTreeBranch</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getDeclGroup</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">getDeclGroup</span><span class="w"> </span><span class="n">r</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that the <code class="docutils literal notranslate"><span class="pre">DeclTreeBranch</span> <span class="pre">l</span> <span class="pre">r</span></code> case will be expensive because it will
merge <em>every combination</em> of elements in the <code class="docutils literal notranslate"><span class="pre">l</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code> groups with list
concatenation. Just this line is enough to change the data structure to a
sequence, again because a sequence has fast merging and cons behavior <a class="footnote-reference brackets" href="#id10" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="optimization-4-fixing-allscopesets">
<h2><span class="section-number">4.3.8. </span>Optimization 4: Fixing allScopeSets<a class="headerlink" href="#optimization-4-fixing-allscopesets" title="Permalink to this heading">¶</a></h2>
<p>We,ve come quite far, but there is still a lot of <code class="docutils literal notranslate"><span class="pre">void</span></code> in the heap profile.
This is a good scenario for info-table profiling. Info-table profiling relates
source code to closures so we can see the exact line of source code the <code class="docutils literal notranslate"><span class="pre">void</span></code>
is originating.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cabal <span class="nb">test</span> --test-show-details<span class="o">=</span>streaming --test-options<span class="o">=</span><span class="s1">&#39;--pattern &quot;implicit-conversion-test&quot; +RTS -hi -i0.05 -l -RTS&#39;</span> --ghc-options<span class="o">=</span><span class="s1">&#39;-eventlog -rtsopts -O2 -finfo-table-map -fdistinct-construct or-tables&#39;</span>
</pre></div>
</div>
<p>and the profile is rendered in eventlog:</p>
<iframe id="scaled-frame" scrolling="no" src="/_static/klister/klister-eventlog-implicit-conversion-ipe-allscopeset.html"></iframe><p>Notice that the legend displays the <a class="reference internal" href="../glossary.html#term-Info-Table-Address"><span class="xref std std-term">Info Table Address</span></a> instead of the
closure type, module, or biography. From the profile we find that <code class="docutils literal notranslate"><span class="pre">0x7c41d0</span></code>
and <code class="docutils literal notranslate"><span class="pre">0xc0c330</span></code> are responsible for the <code class="docutils literal notranslate"><span class="pre">void</span></code> allocation. The detailed tab
maps these addresses directly to source code. In the detailed tab, we see that
<code class="docutils literal notranslate"><span class="pre">0x7c41d0</span></code> has the description <code class="docutils literal notranslate"><span class="pre">sat_sN17_info</span></code>, the closure type <code class="docutils literal notranslate"><span class="pre">THUNK</span></code>,
the type <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code>, and is in the module <code class="docutils literal notranslate"><span class="pre">ScopeSet</span></code> at line 146. That line is
exactly the local <code class="docutils literal notranslate"><span class="pre">combine</span></code> function in <code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code>. Recall that we also
observed <code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code> doing the most allocation in addition to having a high
degree of entries in the ticky profile above. It therefore seems crucial to
optimize the function. Here is the source code:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">allScopeSets</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Data</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Traversal&#39;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="w"></span>
<span class="nf">allScopeSets</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">allScopeSets&#39;</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"></span>
<span class="w">    </span><span class="n">allScopeSets&#39;</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">d</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">Data</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">ScopeSet</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="w">    </span><span class="n">allScopeSets&#39;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">gmapA</span><span class="w"> </span><span class="n">go</span><span class="w"></span>
<span class="w">      </span><span class="kr">where</span><span class="w"></span>
<span class="w">        </span><span class="n">go</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="kt">Data</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">        </span><span class="n">go</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">eqT</span><span class="w"> </span><span class="o">@</span><span class="n">a</span><span class="w"> </span><span class="o">@</span><span class="kt">ScopeSet</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">          </span><span class="kt">Just</span><span class="w"> </span><span class="kt">Refl</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">          </span><span class="kt">Nothing</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">allScopeSets&#39;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="w">    </span><span class="c1">-- A variant of Data.Data.gmapM which uses Applicative instead of Monad</span><span class="w"></span>
<span class="w">    </span><span class="n">gmapA</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">d</span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="kt">Applicative</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">Data</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">forall</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="w"> </span><span class="kt">Data</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="w">    </span><span class="n">gmapA</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">gfoldl</span><span class="w"> </span><span class="n">combine</span><span class="w"> </span><span class="n">pure</span><span class="w"></span>
<span class="w">      </span><span class="kr">where</span><span class="w"></span>
<span class="w">        </span><span class="n">combine</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Data</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">        </span><span class="n">combine</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This code is exceedingly polymorphic and is effectively asking GHC to generate
traversals over many different data types. From the info-table profiling we know
that <code class="docutils literal notranslate"><span class="pre">combine</span></code> is building up thunks of function applications. In the body of
<code class="docutils literal notranslate"><span class="pre">combine</span></code> there are two function application sites: <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">(&lt;*&gt;)</span> <span class="pre">ff</span> <span class="pre">(g</span>
<span class="pre">a)</span></code>. To determine which is responsible we’ll force each and rerun the
info-table profiling, beginning with <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span> <span class="pre">ff</span> <span class="pre">(g</span> <span class="pre">a)</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">combine</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Data</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">combine</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">!</span><span class="n">res</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">res</span><span class="w"></span>
</pre></div>
</div>
<p>Unfortunately, this produces the same profile. Let’s next force <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">a</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">combine</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Data</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">combine</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">!</span><span class="n">ga</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">ga</span><span class="w"></span>
</pre></div>
</div>
<p>and rerun the test:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cabal <span class="nb">test</span> --test-show-details<span class="o">=</span>streaming --enable-profiling --test-options<span class="o">=</span><span class="s1">&#39;--pattern &quot;impl icit-conversion-test&quot; +RTS -hi -i0.05 -l -rticky -RTS&#39;</span> --ghc-options<span class="o">=</span><span class="s1">&#39;-eventlog -rtsopts -ticky -O2 -finfo-table-map -fdistinct-constructor-tables&#39;</span>
<span class="go">  ...</span>
<span class="go">  Running 1 test suites...</span>
<span class="go">  Test suite klister-tests: RUNNING...</span>
<span class="go">  All tests</span>
<span class="go">    Golden tests</span>
<span class="go">      implicit-conversion-test: OK (1919.27s)</span>

<span class="go">  All 1 tests passed (1919.29s)</span>
<span class="go">  Test suite klister-tests: PASS</span>
</pre></div>
</div>
<p>The test finished in 1919.27 seconds; clearly forcing this thunk produced a
regression. The heap profile similarly shows much more memory allocation:</p>
<iframe id="scaled-frame" scrolling="no" src="/_static/klister/klister-eventlog-implicit-conversion-ipe-allscopeset_force_ga.html"></iframe><p>Now this test allocates around 2.6Gb, unfortunately the info-table profiling
does not display the information for the most allocating info table address
<code class="docutils literal notranslate"><span class="pre">0x1b93550</span></code>. We’ll do one last test and make both the entire body and <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">a</span></code>
strict:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">combine</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Data</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">combine</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">!</span><span class="n">ga</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">                   </span><span class="o">!</span><span class="n">res</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">ga</span><span class="w"></span>
<span class="w">                   </span><span class="kr">in</span><span class="w"> </span><span class="n">res</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Running 1 test suites...</span>
<span class="go">Test suite klister-tests: RUNNING...</span>
<span class="go">All tests</span>
<span class="go">  Golden tests</span>
<span class="go">    implicit-conversion-test: OK (1906.82s)</span>

<span class="go">All 1 tests passed (1906.84s)</span>
<span class="go">Test suite klister-tests: PASS</span>
</pre></div>
</div>
<p>Not much better. We saw that <code class="docutils literal notranslate"><span class="pre">combine</span></code> was building up thunks with info-table
profiling, but by forcing those thunks the heap grew from 100Mb to 2.6Gb. So
even though info-table profiling pointed to <code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code>, our problem lies
elsewhere. If <code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code> was the culprit then we would expect an
improvement, which was not observed. But we have learned that <code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code>
is on the critical path of the memory leak. We’ll leave these changes in place
to determine what type of closures are newly leaking:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a common phenomena when plugging memory leaks. By adding strictness
to the critical path the leak is on, it is often the case that the laziness
moves to another part of system until the root cause is discovered. So by
leaving these changes in place we are traversing the critical path that leads
to the leak.</p>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cabal <span class="nb">test</span> --enable-profiling --test-show-details<span class="o">=</span>streaming  --test-options<span class="o">=</span><span class="s1">&#39;--pattern &quot;implicit-conversion-test&quot; +RTS -hy -l-agu -p -L50 -RTS&#39;</span> --ghc-options<span class="o">=</span><span class="s1">&#39;-eventlog -rtsopts -O2&#39;</span>
</pre></div>
</div>
<p>which yields:</p>
<iframe id="scaled-frame" scrolling="no" src="/_static/klister/klister-eventlog-implicit-conversion-ipe-allscopeset_forced_hy.html"></iframe><p>Almost all the memory allocated on the heap is a list <code class="docutils literal notranslate"><span class="pre">[]</span></code> of some type. Let’s
inspect the code path for <code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code>, normally one would do a retainer
analysis to find the right code path, but in this case <code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code> is only
called in one function: <code class="docutils literal notranslate"><span class="pre">visit</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">visit</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">ModuleName</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="kt">Exports</span><span class="w"></span>
<span class="nf">visit</span><span class="w"> </span><span class="n">modName</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">es</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"></span>
<span class="w">    </span><span class="kr">do</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="n">expanderWorld</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getState</span><span class="w"></span>
<span class="w">       </span><span class="kr">case</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="p">(</span><span class="n">worldModules</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">modName</span><span class="p">)</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">         </span><span class="kt">Just</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">           </span><span class="kr">let</span><span class="w"> </span><span class="n">es</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fromMaybe</span><span class="w"> </span><span class="n">noExports</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="p">(</span><span class="n">worldExports</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">modName</span><span class="p">)</span><span class="w"> </span><span class="n">world</span><span class="w"></span>
<span class="w">           </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">es</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="kt">Nothing</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"></span>
<span class="w">           </span><span class="n">inPhase</span><span class="w"> </span><span class="n">runtime</span><span class="w"> </span><span class="o">$</span><span class="w"></span>
<span class="w">             </span><span class="n">loadModuleFile</span><span class="w"> </span><span class="n">modName</span><span class="w"></span>
<span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">currentPhase</span><span class="w"></span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">phaseNum</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="w">  </span><span class="n">visitedp</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">Set</span><span class="o">.</span><span class="n">member</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">.</span><span class="w"></span>
<span class="w">              </span><span class="n">view</span><span class="w"> </span><span class="p">(</span><span class="n">expanderWorld</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">worldVisited</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">modName</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">non</span><span class="w"> </span><span class="kt">Set</span><span class="o">.</span><span class="n">empty</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"></span>
<span class="w">              </span><span class="n">getState</span><span class="w"></span>
<span class="w">  </span><span class="n">unless</span><span class="w"> </span><span class="n">visitedp</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">m&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="c1">-- Shift the syntax literals in the module source code</span><span class="w"></span>
<span class="w">    </span><span class="n">sc</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">freshScope</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">T</span><span class="o">.</span><span class="n">pack</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;For module-phase &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">shortShow</span><span class="w"> </span><span class="n">modName</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">shortShow</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">m&#39;&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="o">.</span><span class="n">allScopeSets</span><span class="w"> </span><span class="p">(</span><span class="kt">ScopeSet</span><span class="o">.</span><span class="n">insertUniversally</span><span class="w"> </span><span class="n">sc</span><span class="p">)</span><span class="w"> </span><span class="n">m&#39;</span><span class="w"></span>
<span class="w">    </span><span class="n">evalResults</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">inPhase</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">evalMod</span><span class="w"> </span><span class="n">m&#39;&#39;</span><span class="w"></span>
<span class="w">    </span><span class="n">modifyState</span><span class="w"> </span><span class="o">$</span><span class="w"></span>
<span class="w">      </span><span class="n">set</span><span class="w"> </span><span class="p">(</span><span class="n">expanderWorld</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">worldEvaluated</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">modName</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">evalResults</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kr">let</span><span class="w"> </span><span class="n">bs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">getModuleBindings</span><span class="w"> </span><span class="n">m&#39;&#39;</span><span class="w"></span>
<span class="w">    </span><span class="n">modifyState</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">expanderGlobalBindingTable</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">bs</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">es</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="n">getModuleBindings</span><span class="w"> </span><span class="p">(</span><span class="kt">Expanded</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">bs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">bs</span><span class="w"></span>
<span class="w">        </span><span class="n">getModuleBindings</span><span class="w"> </span><span class="p">(</span><span class="kt">KernelModule</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mempty</span><span class="w"></span>
</pre></div>
</div>
<p>We see that <code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code> <em>is only</em> used to construct <code class="docutils literal notranslate"><span class="pre">m''</span></code>, by traversing
the data in <code class="docutils literal notranslate"><span class="pre">m'</span></code>, and applying the function <code class="docutils literal notranslate"><span class="pre">ScopeSet.insertUniversally</span></code>
with the argument <code class="docutils literal notranslate"><span class="pre">sc</span></code>. Here is <code class="docutils literal notranslate"><span class="pre">insertUniversally</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insertUniversally</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Scope</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">ScopeSet</span><span class="w"></span>
<span class="nf">insertUniversally</span><span class="w"> </span><span class="n">sc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="p">(</span><span class="n">universalScopes</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">sc</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="nb">()</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>and recall that a <code class="docutils literal notranslate"><span class="pre">Scope</span></code> is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Scope</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Scope</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">scopeNum</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">scopePurpose</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Text</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>which is created in <code class="docutils literal notranslate"><span class="pre">freshScope</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">freshScope</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Text</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="kt">Scope</span><span class="w"></span>
<span class="nf">freshScope</span><span class="w"> </span><span class="n">why</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="n">expanderNextScopeNum</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getState</span><span class="w"></span>
<span class="w">  </span><span class="n">modifyState</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">expanderNextScopeNum</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="kt">Scope</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">why</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Scope</span></code> type is overly lazy and is inefficient. The <code class="docutils literal notranslate"><span class="pre">Int</span></code> is incremented
lazily in <code class="docutils literal notranslate"><span class="pre">freshScope</span></code>, the <code class="docutils literal notranslate"><span class="pre">Text</span></code> is constructed lazily <em>and</em> is only used
for debugging in an error state <a class="footnote-reference brackets" href="#id11" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>. Furthermore, notice that the <code class="docutils literal notranslate"><span class="pre">Eq</span></code> and
<code class="docutils literal notranslate"><span class="pre">Ord</span></code> instances are derived, which means the <code class="docutils literal notranslate"><span class="pre">Text</span></code> field is unnecessarily
scrutinized to insert and balance the <code class="docutils literal notranslate"><span class="pre">Set</span></code> even though the ordinal
information on the <code class="docutils literal notranslate"><span class="pre">Text</span></code> field is not useful to the interpreter. This is
especially problematic given the high entry counts we observed for
<code class="docutils literal notranslate"><span class="pre">isSubsetOf</span></code> and <code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code>.</p>
<p>To fix the <code class="docutils literal notranslate"><span class="pre">Scope</span></code> type we’ll make the <code class="docutils literal notranslate"><span class="pre">Int</span></code> field strict, remove the
<code class="docutils literal notranslate"><span class="pre">Text</span></code> field entirely and inline <code class="docutils literal notranslate"><span class="pre">freshScope</span></code> . The <code class="docutils literal notranslate"><span class="pre">Int</span></code> field should be
strict to ensure the increments do not accumulate thunks and to make sure GHC
will unpack the <code class="docutils literal notranslate"><span class="pre">Int</span></code>. We could choose to make the <code class="docutils literal notranslate"><span class="pre">Text</span></code> field strict, but
this would be a mistake because the <code class="docutils literal notranslate"><span class="pre">Text</span></code> field <em>is only</em> used in an error
state, so making it strict would mean allocating memory in a hot loop when it is
unnecessary to do so. Furthermore, removing the <code class="docutils literal notranslate"><span class="pre">Text</span></code> field unlocks better
data structures; with its removal we can use a <code class="docutils literal notranslate"><span class="pre">newtype</span></code> instead of a <code class="docutils literal notranslate"><span class="pre">data</span></code>
type, thereby reducing allocations, and use an <code class="docutils literal notranslate"><span class="pre">IntSet</span></code> instead of a <code class="docutils literal notranslate"><span class="pre">Set</span></code>.
An <code class="docutils literal notranslate"><span class="pre">IntSet</span></code> is similar to an <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> (it is also implemented as a
big-endian PATRICIA trie) but the implementation in <code class="docutils literal notranslate"><span class="pre">containers</span></code> is tuned for
dense sets (where the elements are close in value), which is the kind of
<code class="docutils literal notranslate"><span class="pre">IntSet</span></code> the klister interpreter generates.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Text</span></code> field is allocated in this line:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span><span class="w"></span>
<span class="w">    </span><span class="n">sc</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">freshScope</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">T</span><span class="o">.</span><span class="n">pack</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;For module-phase &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">shortShow</span><span class="w"> </span><span class="n">modName</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">shortShow</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>We’ll test that this is the source of the <code class="docutils literal notranslate"><span class="pre">[]</span></code> (due to the <code class="docutils literal notranslate"><span class="pre">String</span></code>) by
forcing the <code class="docutils literal notranslate"><span class="pre">Text</span></code> object, and then rerun a closure type heap profile to
observe any changes:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span><span class="w"></span>
<span class="w">    </span><span class="n">sc</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">freshScope</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="kt">T</span><span class="o">.</span><span class="n">pack</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="s">&quot;For module-phase &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">shortShow</span><span class="w"> </span><span class="n">modName</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">shortShow</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Notice, the strict application: <code class="docutils literal notranslate"><span class="pre">$!</span></code>, after <code class="docutils literal notranslate"><span class="pre">freshScope</span></code>. Here is the heap
profile:</p>
<iframe id="scaled-frame" scrolling="no" src="/_static/klister/klister-eventlog-implicit-conversion-allscope-fixed.html"></iframe><p>Much better, the interpreter is still leaking <code class="docutils literal notranslate"><span class="pre">[]</span></code> but the heap stays under
50Mb. We have found the memory leak. Now we’ll go further and remove the
<code class="docutils literal notranslate"><span class="pre">Text</span></code> field from <code class="docutils literal notranslate"><span class="pre">Scope</span></code> and change <code class="docutils literal notranslate"><span class="pre">ScopeSet</span></code> to use <code class="docutils literal notranslate"><span class="pre">IntSet</span></code>. To
preserve the ability to debug we’ll use a CPP pragma that includes the <code class="docutils literal notranslate"><span class="pre">Text</span></code>
field for a debug build and elides it for a normal build. Here are the final
definitions:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Util.Set is an IntSet with more type information</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">unSet</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IntSet</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="kr">newtype</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">Semigroup</span><span class="p">,</span><span class="w"> </span><span class="kt">Monoid</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="n">stock</span><span class="w">   </span><span class="kt">Data</span><span class="w"></span>
<span class="kr">type</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="kt">Set</span><span class="w"> </span><span class="n">representational</span><span class="w"></span>

<span class="c1">-- In Scope.hs</span><span class="w"></span>
<span class="o">#</span><span class="n">ifndef</span><span class="w"> </span><span class="kt">KDEBUG</span><span class="w"></span>
<span class="kr">newtype</span><span class="w"> </span><span class="kt">Scope</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Scope</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">scopeNum</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="kr">newtype</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">,</span><span class="w"> </span><span class="kt">HasKey</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="n">stock</span><span class="w"> </span><span class="kt">Data</span><span class="w"></span>
<span class="o">#</span><span class="kr">else</span><span class="w"></span>
<span class="c1">-- For a debug build Scope keeps a blob of text for debugging the expander</span><span class="w"></span>
<span class="c1">-- output. This will have an impact of the performance of the interpreter so it</span><span class="w"></span>
<span class="c1">-- won&#39;t be useful for performance issues</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Scope</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Scope</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">scopeNum</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">scopePurpose</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Text</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">deriving</span><span class="w"> </span><span class="p">(</span><span class="kt">Data</span><span class="p">,</span><span class="w"> </span><span class="kt">Eq</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="p">,</span><span class="w"> </span><span class="kt">Show</span><span class="p">)</span><span class="w"></span>
<span class="o">#</span><span class="n">endif</span><span class="w"></span>

<span class="o">#</span><span class="n">ifndef</span><span class="w"> </span><span class="kt">KDEBUG</span><span class="w"></span>
<span class="nf">freshScope</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Text</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="kt">Scope</span><span class="w"></span>
<span class="cm">{-# INLINE freshScope #-}</span><span class="w"></span>
<span class="nf">freshScope</span><span class="w"> </span><span class="n">_why</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="n">expanderNextScopeNum</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getState</span><span class="w"></span>
<span class="w">  </span><span class="n">modifyState</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">expanderNextScopeNum</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="kt">Scope</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="o">#</span><span class="kr">else</span><span class="w"></span>
<span class="nf">freshScope</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Text</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Expand</span><span class="w"> </span><span class="kt">Scope</span><span class="w"></span>
<span class="cm">{-# INLINE freshScope #-}</span><span class="w"></span>
<span class="nf">freshScope</span><span class="w"> </span><span class="n">why</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"></span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="n">expanderNextScopeNum</span><span class="w"> </span><span class="o">&lt;$&gt;</span><span class="w"> </span><span class="n">getState</span><span class="w"></span>
<span class="w">  </span><span class="n">modifyState</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">expanderNextScopeNum</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="kt">Scope</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">why</span><span class="p">)</span><span class="w"></span>
<span class="o">#</span><span class="n">endif</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that the API to <code class="docutils literal notranslate"><span class="pre">freshScope</span></code> does not change. In total, there are 11
more call sites to <code class="docutils literal notranslate"><span class="pre">freshScope</span></code> throughout the interpreter that are leaking.
So if we had changed the API then the CPP would proliferate even more. To avoid
the extra CPP we inline <code class="docutils literal notranslate"><span class="pre">freshScope</span></code>; this will ensure that in a non-debug
build GHC will determine that the <code class="docutils literal notranslate"><span class="pre">Text</span></code> argument is dead and remove it,
thereby clearing the memory leaks at each call site.</p>
<p>Now we’ll revert the strictness changes in <code class="docutils literal notranslate"><span class="pre">allScopeSets</span></code> and check the
runtime of <code class="docutils literal notranslate"><span class="pre">implicit-conversion-test</span></code> to observe the effect of our
optimizations:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cabal <span class="nb">test</span> --test-show-details<span class="o">=</span>streaming --test-options<span class="o">=</span><span class="s1">&#39;--pattern &quot;implicit-conversion-test&quot;&#39;</span> --ghc-options<span class="o">=</span><span class="s1">&#39;-O2&#39;</span>
<span class="go">  ...</span>
<span class="go">  Test suite klister-tests: RUNNING...</span>
<span class="go">  All tests</span>
<span class="go">    Golden tests</span>
<span class="go">      implicit-conversion-test: OK (1.10s)</span>

<span class="go">  All 1 tests passed (1.11s)</span>
<span class="go">  Test suite klister-tests: PASS</span>
</pre></div>
</div>
<p>Much better, <code class="docutils literal notranslate"><span class="pre">implicit-conversion-test</span></code> is about nine times faster. Let’s
rerun the entire test suite to check the progress we’ve made. Recall that the
testsuite originally took 38 seconds to finish.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cabal <span class="nb">test</span> --test-show-details<span class="o">=</span>streaming --ghc-options<span class="o">=</span><span class="s1">&#39;-O2&#39;</span>
<span class="go">  ...</span>
<span class="go">  Test suite klister-tests: RUNNING...</span>
<span class="go">  All tests</span>
<span class="go">      Module tests</span>
<span class="go">        Expected to succeed</span>
<span class="go">          ...</span>
<span class="go">          examples/lang.kl:                              OK (0.03s)</span>
<span class="go">          examples/import.kl:                            OK (0.03s)</span>
<span class="go">          examples/macro-body-shift.kl:                  OK (0.03s)</span>
<span class="go">          examples/test-quasiquote.kl:                   OK (0.03s)</span>
<span class="go">          examples/quasiquote-syntax-test.kl:            OK (0.03s)</span>
<span class="go">          examples/hygiene.kl:                           OK (0.27s)</span>
<span class="go">          examples/defun-test.kl:                        OK (0.02s)</span>
<span class="go">          examples/fun-exports-test.kl:                  OK (0.03s)</span>
<span class="go">    Golden tests</span>
<span class="go">      test-quasiquote:                                   OK (0.03s)</span>
<span class="go">      io:                                                OK (0.03s)</span>
<span class="go">      defun-test:                                        OK (0.02s)</span>
<span class="go">      contract:                                          OK (0.08s)</span>
<span class="go">      int-ops:                                           OK (0.03s)</span>
<span class="go">      implicit-conversion:                               OK (0.99s)</span>
<span class="go">      implicit-conversion-test:                          OK (1.11s)</span>
<span class="go">      higher-kinded-patterns:                            OK (0.39s)</span>
<span class="go">      custom-literals-test:                              OK (0.20s)</span>
<span class="go">      double-define:                                     OK (0.18s)</span>
<span class="go">      custom-module-test:                                OK (0.22s)</span>
<span class="go">      which-problem:                                     OK (0.24s)</span>
<span class="go">      incorrect-context:                                 OK (0.02s)</span>
<span class="go">      bound-vs-free:                                     OK (0.13s)</span>
<span class="go">      meta-macro:                                        OK (0.08s)</span>
<span class="go">      integer-syntax:                                    OK (0.03s)</span>
<span class="go">      import:                                            OK (0.03s)</span>

<span class="go">  All 124 tests passed (9.89s)</span>
<span class="go">  Test suite klister-tests: PASS</span>
</pre></div>
</div>
<p>The entire test suite finished in just under 10 seconds, or about as fast as
<code class="docutils literal notranslate"><span class="pre">implicit-conversion-test</span></code> finished originally. <code class="docutils literal notranslate"><span class="pre">implicit-conversion-test</span></code>
is also not the only test that benefited. Almost every test is faster; for
example, <code class="docutils literal notranslate"><span class="pre">which-problem</span></code> finishes in 240 ms compared to 820 ms,
<code class="docutils literal notranslate"><span class="pre">double-define</span></code> finishes in 180 ms compared to 340 ms. Our work here is done
for now.</p>
</section>
<section id="summing-up">
<h2><span class="section-number">4.3.9. </span>Summing up<a class="headerlink" href="#summing-up" title="Permalink to this heading">¶</a></h2>
<p>Our goal was to speed up the klister interpreter. To do so we found a poor
performing test and focused on the macro expander subsystem of the interpreter.
Then we employed a number of methods to find performance problems. We used:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../Measurement_Observation/Measurement_Ghc/ticky_ticky.html#ticky-chapter"><span class="std std-ref">Ticky Profiling</span></a>: To determine hot loops and highly
allocating functions</p></li>
<li><p><a class="reference internal" href="../Measurement_Observation/Heap_Ghc/ghc_flags.html#heap-profiling-chapter"><span class="std std-ref">Biographical/Retainer Profiling</span></a>: To determine
the source of memory leaks in the expander state. This technique led our
analysis to the lazy return in <code class="docutils literal notranslate"><span class="pre">currentEnv</span></code>.</p></li>
<li><p><a class="reference internal" href="../Measurement_Observation/Heap_Ghc/info_table.html#ipe-chapter"><span class="std std-ref">Info-Table Profiling</span></a>: To determine the line of code
closures on the heap came from. This technique led our analysis to the
<code class="docutils literal notranslate"><span class="pre">visit</span></code> function and ultimately to the leaky <code class="docutils literal notranslate"><span class="pre">Text</span></code> field <code class="docutils literal notranslate"><span class="pre">Scope</span></code>.</p></li>
</ul>
<p>Key to our analysis was a careful debugging process. We:</p>
<ol class="arabic simple">
<li><p>Found a reproducible test case.</p></li>
<li><p>Didn’t guess, instead we looked: We used GHC’s instrumentation to develop
hypotheses about the klister interpreter’s performance instead of guessing
and performing <a class="reference external" href="https://en.wikipedia.org/wiki/Shotgun_debugging">shotgun debugging</a>.</p></li>
<li><p>Only changed one thing at a time: We tried to only change a single function,
or a single type at a time. Then, if we did not observe any difference with
the instrumentation we reverted the change.</p></li>
</ol>
<p>Could we have gone farther? Of course. The interpreter is still leaking <code class="docutils literal notranslate"><span class="pre">[]</span></code>
even though the heap stays under 50Mb. In the end, the optimizations were
trivial; we only chose better data structures and closed memory leaks. We could
still optimize or memoize <code class="docutils literal notranslate"><span class="pre">isSubsetOf</span></code>, unroll the <code class="docutils literal notranslate"><span class="pre">Expander</span></code> monad
transformer, fix the expander’s use of the <code class="docutils literal notranslate"><span class="pre">WriterT</span></code> monad transformer; which
is well known to leak memory <a class="footnote-reference brackets" href="#id12" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>, do some manual loop fusion, or <a class="reference internal" href="../Optimizations/Code_Changes/oneshot.html#oneshot-monad-chapter"><span class="std std-ref">oneShot</span></a> the expander monad. But for a first pass our results
are good enough.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id8" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>What I have in mind is a <a class="reference external" href="https://en.wikipedia.org/wiki/Pareto_front#:~:text=In%20multi%2Dobjective%20optimization%2C%20the,is%20widely%20used%20in%20engineering.">Pareto Frontier</a>
for the interpreter.</p>
</aside>
<aside class="footnote brackets" id="id9" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>Based on data in the <a class="reference external" href="https://github.com/haskell-perf/dictionaries">Haskell Performance repository</a>. This difference is on the order of a few nanoseconds for
maps with 10 elements, grows to a difference of 1.2 microseconds at 1000
elements. By 10000 elements <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> consistently outperforms
<code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>.</p>
</aside>
<aside class="footnote brackets" id="id10" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">3</a><span class="fn-bracket">]</span></span>
<p>We’re eliding the code that shows this use case because it is
uninteresting. Furthermore, the klister developers have confirmed this is
the fields purpose.</p>
</aside>
<aside class="footnote brackets" id="id11" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">4</a><span class="fn-bracket">]</span></span>
<p>See the sequences comparison in the <a class="reference external" href="https://github.com/haskell-perf/sequences">Haskell Performance
repository</a>.</p>
</aside>
<aside class="footnote brackets" id="id12" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">5</a><span class="fn-bracket">]</span></span>
<p>The leakiness and excess laziness of <code class="docutils literal notranslate"><span class="pre">Writer/WriterT</span></code> have been well
documented. See the Haskell mailing list <a class="reference external" href="https://mail.haskell.org/pipermail/libraries/2012-October/018599.html">Stricter WriterT monad
transformer</a>
and <a class="reference external" href="https://mail.haskell.org/pipermail/libraries/2013-March/019528.html">Stricter WriterT (Part II)</a>.
This <a class="reference external" href="https://journal.infinitenegativeutility.com/writer-monads-and-space-leaks">blog post</a>
also has a good review.</p>
</aside>
</aside>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="sbv_642.html"
       title="previous chapter">← <span class="section-number">4.2. </span>SBV and the Bizarre GHC Regression</a>
  </li>
  <li class="next">
    <a href="../glossary.html"
       title="next chapter">Glossary →</a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; Copyright 2022-2023, Jeffrey Young (doyougnu).
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.1.1 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>