<!DOCTYPE html>
<html  lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="viewport" content="width=device-width, initial-scale=1" />

      <title>2.6.3. Eventlog</title>
    
          <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/theme.css " type="text/css" />
          <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/css/s4defs-roles.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/css/iframe.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/css/admonitions.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/css/s4defs-roles.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/css/iframe.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/css/admonitions.css" type="text/css" />
      
      <!-- sphinx script_files -->
        <script src="../../../_static/documentation_options.js?v=d45e8c67"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=f281be69"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../../../_static/theme-vendors.js"></script> -->
      <script src="../../../_static/theme.js" defer></script>
    
  <link rel="index" title="Index" href="../../../genindex.html" />
  <link rel="search" title="Search" href="../../../search.html" />
  <link rel="next" title="2.6.4. Criterion, Gauge, and Tasty-Bench" href="criterion.html" />
  <link rel="prev" title="2.6.2. Info-Table Profiling" href="info_table.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../../contents.html" class="home-link">
    
      <span class="site-name">Haskell Optimization Handbook</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">

  
    <div class="nav-item">
      <a href="../../../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../../../contents.html#indices-and-tables"
         class="nav-link ">
         indices and tables
      </a>
    </div>
  



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            

  
    <div class="nav-item">
      <a href="../../../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../../../contents.html#indices-and-tables"
         class="nav-link ">
         indices and tables
      </a>
    </div>
  



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Quick search</span>
    <div class="searchformwrapper">
      <form class="search" action="../../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Search" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../../contents.html#haskell-optimization-handbook">Table of Contents</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../../Preliminaries/index.html" class="reference internal ">Preliminaries</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../index.html" class="reference internal ">Measurement, Profiling, and Observation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../../Optimizations/index.html" class="reference internal ">Optimizations</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../../Case_Studies/index.html" class="reference internal ">Case Studies</a>
            

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../../contents.html#indices-and-tables">indices and tables</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../../glossary.html" class="reference internal ">Glossary</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../../contents.html">Docs</a> &raquo;</li>
    
      <li><a href="../index.html"><span class="section-number">2. </span>Measurement, Profiling, and Observation</a> &raquo;</li>
    
      <li><a href="index.html"><span class="section-number">2.6. </span>Haskell Level Probing and Profiling</a> &raquo;</li>
    
    <li><span class="section-number">2.6.3. </span>Eventlog</li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="info_table.html"
       title="previous chapter">← <span class="section-number">2.6.2. </span><span class="lightgrey">Info-Table Profiling</span></a>
  </li>
  <li class="next">
    <a href="criterion.html"
       title="next chapter"><span class="section-number">2.6.4. </span><span class="lightgrey">Criterion, Gauge, and Tasty-Bench</span> →</a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <span class="target" id="eventlog-chapter"></span><section id="eventlog">
<h1><span class="section-number">2.6.3. </span>Eventlog<a class="headerlink" href="#eventlog" title="Link to this heading">¶</a></h1>
<p><a class="reference external" href="https://downloads.haskell.org/~ghc/9.2.4/docs/html/users_guide/runtime_control.html#rts-eventlog">Eventlog</a> is a GHC runtime
system feature that logs events at runtime of a compiled program. It provides
runtime information on the heap, the garbage collector, the scheduler, and
arbitrary events that a user inserts into their own code. Eventlog is a
versatile profiling tool, and should be one of the first tools in the profiling
toolbox you reach for. Use eventlog when you are just beginning to diagnose the
problem and are gathering data. Specifically when you want to inspect the heap
or some other subsystem, such as the garbage collector. This chapter walks
through using eventlog to inspect a small program that suffers from
<a class="reference internal" href="../../Preliminaries/what_makes_fast_hs.html#canonical-pointer-chasing"><span class="std std-ref">Excessive Pointer Chasing</span></a>. By the end of the chapter you should
understand:</p>
<ol class="arabic simple">
<li><p>What information can you retrieve by using eventlog.</p></li>
<li><p>When to use eventlog.</p></li>
<li><p>How to build your program to use eventlog.</p></li>
<li><p>How to visualize eventlog information.</p></li>
<li><p>How to tune eventlog to inspect specific sub-system.</p></li>
<li><p>How to tune eventlog to inspect specific pieces of code.</p></li>
</ol>
<section id="requirements">
<h2><span class="section-number">2.6.3.1. </span>Requirements<a class="headerlink" href="#requirements" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>The program must be recompiled with the <code class="docutils literal notranslate"><span class="pre">-eventlog</span></code> GHC flag</p></li>
<li><p>A program to consume the <code class="docutils literal notranslate"><span class="pre">&lt;program&gt;.eventlog</span></code> file. We recommend
<a class="reference external" href="https://mpickering.github.io/eventlog2html/">eventlog2html</a>; see also the relevant section in the <a class="reference external" href="https://downloads.haskell.org/~ghc/9.2.4/docs/html/users_guide/runtime_control.html#rts-eventlog">GHC User’s
Guide</a>. You can also parse the
<code class="docutils literal notranslate"><span class="pre">&lt;program&gt;.eventlog</span></code> file using the <a class="reference external" href="https://hackage.haskell.org/package/ghc-events">ghc-events</a> library.</p></li>
</ol>
</section>
<section id="restrictions">
<h2><span class="section-number">2.6.3.2. </span>Restrictions<a class="headerlink" href="#restrictions" title="Link to this heading">¶</a></h2>
<p>Eventlog is portable, and should work anywhere GHC’s native runtime system will work.</p>
</section>
<section id="what-information-do-i-receive-from-eventlog">
<h2><span class="section-number">2.6.3.3. </span>What Information Do I Receive From Eventlog?<a class="headerlink" href="#what-information-do-i-receive-from-eventlog" title="Link to this heading">¶</a></h2>
<p>Eventlog logs events as a function of elapsed walltime. A full list of possible
events is available in <a class="reference external" href="https://downloads.haskell.org/~ghc/9.2.4/docs/html/users_guide/runtime_control.html#rts-eventlog">GHC User’s Guide</a>. In general, the most common use case is to
track heap events; which will be the focus of this chapter. However, a user may
define and track their own events using the base functions <a class="reference external" href="https://downloads.haskell.org/~ghc/9.2.4/docs/html/libraries/base-4.16.3.0/Debug-Trace.html#v:traceMarker">traceEvent</a>.</p>
</section>
<section id="when-should-i-use-eventlog">
<h2><span class="section-number">2.6.3.4. </span>When should I use Eventlog<a class="headerlink" href="#when-should-i-use-eventlog" title="Link to this heading">¶</a></h2>
<p>Eventlog is most useful when you need to characterize the problem. It yields
runtime information on the specific sub-system the program relies on. Thus, it
allows you to drill down into the behavior of the garbage collector, the
scheduler, the heap and so. For example, using the flag <code class="docutils literal notranslate"><span class="pre">+RTS</span> <span class="pre">-lg</span></code> you can
collect the <code class="docutils literal notranslate"><span class="pre">CONC_MARK_BEGIN</span></code> and <code class="docutils literal notranslate"><span class="pre">CONC_MARK_END</span></code> events which log the
beginning and end of the concurrent garbage collectors marking phase. Similarly,
you can collect <code class="docutils literal notranslate"><span class="pre">MEM_RETURN</span></code> which provides information about the current
allocation of megablocks, attempts to return them to the operating system, and
heap fragmentation.</p>
</section>
<section id="the-running-example">
<h2><span class="section-number">2.6.3.5. </span>The Running Example<a class="headerlink" href="#the-running-example" title="Link to this heading">¶</a></h2>
<p>We’ll use a toy program to demonstrate heap profiling with eventlog. Our toy
program is an example of excessive pointer chasing and should be familiar to
most Haskellers’ as a traditional example of a memory leak:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE BangPatterns #-}</span>
<span class="c1">-- Need to disable optimizations because GHC will recognize and perform</span>
<span class="c1">-- let-floating for us!</span>
<span class="cm">{-# OPTIONS_GHC -O0 -ddump-simpl -ddump-to-file -ddump-stg-final #-}</span>

<span class="kr">module</span><span class="w"> </span><span class="nn">Main</span><span class="w"> </span><span class="kr">where</span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Data.List</span><span class="w">              </span><span class="p">(</span><span class="nf">foldl&#39;</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">System.Random</span><span class="w">          </span><span class="p">(</span><span class="nf">mkStdGen</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">System.Random.Stateful</span><span class="w"> </span><span class="p">(</span><span class="nf">newIOGenM</span><span class="p">,</span><span class="w"> </span><span class="nf">uniformRM</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Control.Concurrent</span><span class="w">     </span><span class="p">(</span><span class="nf">threadDelay</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Control.Monad</span><span class="w">          </span><span class="p">(</span><span class="nf">replicateM</span><span class="p">)</span>

<span class="nf">lazy_mean</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">lazy_mean</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="n">ln</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="nf">stricter_mean</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">stricter_mean</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="n">ln</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl&#39;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="nf">strict_mean</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">strict_mean</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="n">ln</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl&#39;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="c1">-- generate random test data</span>
<span class="w">  </span><span class="n">seed</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">newIOGenM</span><span class="w"> </span><span class="p">(</span><span class="n">mkStdGen</span><span class="w"> </span><span class="mi">1729</span><span class="p">)</span>
<span class="w">  </span><span class="n">test_values</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">replicateM</span><span class="w"> </span><span class="mi">500000</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">uniformRM</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">500000</span><span class="p">)</span><span class="w"> </span><span class="n">seed</span>
<span class="w">  </span><span class="c1">-- sleep for a second</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">wait</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">threadDelay</span><span class="w"> </span><span class="mi">1000000</span>
<span class="w">  </span><span class="c1">-- now run</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">lazy_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">stricter_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">strict_mean</span><span class="w"> </span><span class="n">test_values</span>
</pre></div>
</div>
<p>We define three functions, each of which calculate a geometric mean from a list
of Doubles. <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> uses a lazy left fold, <code class="docutils literal notranslate"><span class="pre">stricter_mean</span></code> uses a strict
left fold but will still leak memory because <code class="docutils literal notranslate"><span class="pre">foldl'</span></code> evaluates the result of
<code class="docutils literal notranslate"><span class="pre">step</span></code> to <a class="reference internal" href="../../glossary.html#term-WHNF"><span class="xref std std-term">WHNF</span></a>. <code class="docutils literal notranslate"><span class="pre">step</span></code> returns a tuple whose WHNF is a tuple
constructor. Thus, <code class="docutils literal notranslate"><span class="pre">stricter_mean</span></code> will leak memory because the elements of
the tuple <em>are still</em> lazy. <code class="docutils literal notranslate"><span class="pre">strict_mean</span></code> fixes this by adding bang patterns
<em>inside</em> the tuple, thereby forcing the elements to evaluate to WHNF; which is
just a value for <code class="docutils literal notranslate"><span class="pre">Double</span></code>.</p>
<p>GHC is good at spotting such code patterns so we’ve turned off optimizations
with the <code class="docutils literal notranslate"><span class="pre">OPTIONS_GHC</span> <span class="pre">-O0</span></code> pragma.</p>
</section>
<section id="the-setup">
<h2><span class="section-number">2.6.3.6. </span>The Setup<a class="headerlink" href="#the-setup" title="Link to this heading">¶</a></h2>
<p>Using Eventlog requires three pieces of setup. First, you must build your
programs with the <code class="docutils literal notranslate"><span class="pre">-eventlog</span> <span class="pre">-rtsopts</span> <span class="pre">-prof</span></code> GHC flags (or alternatively set
<code class="docutils literal notranslate"><span class="pre">profiling:</span> <span class="pre">True</span></code> in <code class="docutils literal notranslate"><span class="pre">cabal.project</span></code> or enable <code class="docutils literal notranslate"><span class="pre">library-profiling</span></code> and
<code class="docutils literal notranslate"><span class="pre">executable-profiling</span></code> in <code class="docutils literal notranslate"><span class="pre">stack.yaml</span></code>.). For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">benchmark</span> <span class="n">pointerChasing</span>
  <span class="nb">type</span>            <span class="p">:</span> <span class="n">exitcode</span><span class="o">-</span><span class="n">stdio</span><span class="o">-</span><span class="mf">1.0</span>
  <span class="n">default</span><span class="o">-</span><span class="n">language</span><span class="p">:</span> <span class="n">Haskell2010</span>
  <span class="n">ghc</span><span class="o">-</span><span class="n">options</span>     <span class="p">:</span> <span class="o">-</span><span class="n">fforce</span><span class="o">-</span><span class="n">recomp</span> <span class="o">-</span><span class="n">threaded</span> <span class="o">-</span><span class="n">rtsopts</span> <span class="o">-</span><span class="n">prof</span> <span class="o">-</span><span class="n">eventlog</span>
  <span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="p">:</span> <span class="n">base</span> <span class="o">&gt;=</span> <span class="mf">4.15</span>
               <span class="p">,</span> <span class="n">containers</span>
               <span class="p">,</span> <span class="n">deepseq</span>
               <span class="p">,</span> <span class="n">gauge</span>
               <span class="p">,</span> <span class="n">random</span>
  <span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="p">:</span> <span class="n">bench</span><span class="o">/</span><span class="n">PointerChasing</span>
  <span class="n">main</span><span class="o">-</span><span class="ow">is</span><span class="p">:</span> <span class="n">Main</span><span class="o">.</span><span class="n">hs</span>
</pre></div>
</div>
<p>Second, you must pass the RTS flag <code class="docutils literal notranslate"><span class="pre">-l</span></code> to your program <em>and</em> additional RTS
flags that describe which events to track. Lastly, you must pass RTS flags to
describe the kind of heap information to collect. Here are some examples of RTS
flag combinations:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;program&gt;</span> <span class="pre">+RTS</span> <span class="pre">-hy</span> <span class="pre">-l-agu</span> <span class="pre">-RTS</span></code>: Do not track all possible events
(<code class="docutils literal notranslate"><span class="pre">-a</span></code>), but track all garbage collector events (<code class="docutils literal notranslate"><span class="pre">g</span></code>), all user events
(<code class="docutils literal notranslate"><span class="pre">u</span></code>), and produce a heap profile by type (<code class="docutils literal notranslate"><span class="pre">-hy</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;program&gt;</span> <span class="pre">+RTS</span> <span class="pre">-hr</span> <span class="pre">-la</span> <span class="pre">-RTS</span></code>: Trace all possible events (<code class="docutils literal notranslate"><span class="pre">a</span></code>) and
produce a heap profile by retainer (<code class="docutils literal notranslate"><span class="pre">-hr</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;program&gt;</span> <span class="pre">+RTS</span> <span class="pre">-hb</span> <span class="pre">-l-asu</span> <span class="pre">-RTS</span></code>: Do not track all possible events
(<code class="docutils literal notranslate"><span class="pre">-a</span></code>), but track all scheduler events (<code class="docutils literal notranslate"><span class="pre">s</span></code>), all user events (<code class="docutils literal notranslate"><span class="pre">u</span></code>),
and produce a heap profile by biography (<code class="docutils literal notranslate"><span class="pre">-hb</span></code>).</p></li>
</ol>
</section>
<section id="visualizing-the-heap-eventlog-by-type">
<h2><span class="section-number">2.6.3.7. </span>Visualizing the Heap: Eventlog by Type<a class="headerlink" href="#visualizing-the-heap-eventlog-by-type" title="Link to this heading">¶</a></h2>
<p>To view the heap profile we’ll use <a class="reference external" href="https://mpickering.github.io/eventlog2html/">eventlog2html</a>. To begin we’ll inspect the
heap by type. Our initial goal is to determine if we have a memory leak and if
so which type is leaking. Here is the cabal file entry and invocation:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For subsequent runs, we will elide the complete output</p>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>cabal<span class="w"> </span>bench<span class="w"> </span>pointerChasing<span class="w"> </span>--benchmark-options<span class="o">=</span><span class="s1">&#39;+RTS -hy -l-agu -RTS&#39;</span>
Build<span class="w"> </span>profile:<span class="w"> </span>-w<span class="w"> </span>ghc-9.2.4<span class="w"> </span>-O1
In<span class="w"> </span>order,<span class="w"> </span>the<span class="w"> </span>following<span class="w"> </span>will<span class="w"> </span>be<span class="w"> </span>built<span class="w"> </span><span class="o">(</span>use<span class="w"> </span>-v<span class="w"> </span><span class="k">for</span><span class="w"> </span>more<span class="w"> </span>details<span class="o">)</span>:
<span class="w"> </span>-<span class="w"> </span>lethargy-0.1.0.0<span class="w"> </span><span class="o">(</span>bench:pointerChasing<span class="o">)</span><span class="w"> </span><span class="o">(</span>first<span class="w"> </span>run<span class="o">)</span>
Preprocessing<span class="w"> </span>benchmark<span class="w"> </span><span class="s1">&#39;pointerChasing&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span>lethargy-0.1.0.0..
Building<span class="w"> </span>benchmark<span class="w"> </span><span class="s1">&#39;pointerChasing&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span>lethargy-0.1.0.0..
<span class="o">[</span><span class="m">1</span><span class="w"> </span>of<span class="w"> </span><span class="m">1</span><span class="o">]</span><span class="w"> </span>Compiling<span class="w"> </span>Main<span class="w">             </span><span class="o">(</span><span class="w"> </span>bench/PointerChasing/Main.hs,<span class="w"> </span>/home/doyougnu/writing/iohk/hs-opt-handbook.github.io/code/lethargy/dist-newstyle/build/x86_64-linux/ghc-9.2.4/lethargy-0.1.0.0/b/pointerChasing/build/pointerChasing/pointerChasing-tmp/Main.o<span class="w"> </span><span class="o">)</span>
<span class="o">[</span><span class="m">1</span><span class="w"> </span>of<span class="w"> </span><span class="m">1</span><span class="o">]</span><span class="w"> </span>Compiling<span class="w"> </span>Main<span class="w">             </span><span class="o">(</span><span class="w"> </span>bench/PointerChasing/Main.hs,<span class="w"> </span>/home/doyougnu/writing/iohk/hs-opt-handbook.github.io/code/lethargy/dist-newstyle/build/x86_64-linux/ghc-9.2.4/lethargy-0.1.0.0/b/pointerChasing/build/pointerChasing/pointerChasing-tmp/Main.o<span class="w"> </span><span class="o">)</span>
Linking<span class="w"> </span>/home/doyougnu/writing/iohk/hs-opt-handbook.github.io/code/lethargy/dist-newstyle/build/x86_64-linux/ghc-9.2.4/lethargy-0.1.0.0/b/pointerChasing/build/pointerChasing/pointerChasing<span class="w"> </span>...
Running<span class="w"> </span><span class="m">1</span><span class="w"> </span>benchmarks...
Benchmark<span class="w"> </span>pointerChasing:<span class="w"> </span>RUNNING...
<span class="m">250137</span>.43193906464
<span class="m">250137</span>.43193906464
<span class="m">250137</span>.43193906464
Benchmark<span class="w"> </span>pointerChasing:<span class="w"> </span>FINISH

$<span class="w"> </span>eventlog2html<span class="w"> </span>pointerChasing.eventlog

$<span class="w"> </span>firefox<span class="w"> </span>pointerChasing.eventlog.html
</pre></div>
</div>
<p>We ask cabal to run the benchmark, and generate an eventlog of only (-a)
user (u) and GC (g) events with a heap profile by type (-hy); which yields the
following heap profile:</p>
<iframe id="scaled-frame" scrolling="no" src="../../../_static/eventlog/pc_heap_type.html"></iframe><div class="admonition note">
<p class="admonition-title">Note</p>
<p>The heap profile is not a static image! Try clicking through the
interactive output from eventlog2html along with the text.</p>
</div>
<p>The heap profile is similar to profiles generated by <a class="reference internal" href="../../Optimizations/GHC_tech/ghc_flags.html#ghc-flags"><span class="std std-ref">traditional tools</span></a> with some notable exceptions. First, this is a more interactive
plot; for example, you can hover your mouse over a section of the profile and a
popup will describe the corresponding description from the legend. You can also
select an element on the legend to filter the plot to only that element. Second,
eventlog2html produces more plots than just the area chart. It produces a
normalized area chart, a <a class="reference external" href="https://en.wikipedia.org/wiki/Streamgraph">streamgraph</a>, a linechart, a heap breakdown by
size of allocations (not count), and a detailed heap breakdown by every element
in the legend.</p>
<p>Each chart serves different purposes and are useful; to show a particular
chart, click its name in the black bar above the main plot area.</p>
<p>The normalized area chart shows the portion of allocations by type. This
makes it easy to see that after 0.8 seconds ~60% of allocations are of type
<code class="docutils literal notranslate"><span class="pre">[]</span></code>. Use the normalized area chart to view the composition of the heap at a
given time.</p>
<p>The streamgraph is similar to the normalized area chart, except that
streamgraph’s show the evolution of allocations by a breakdown, such as type, by
time.</p>
<p>From the streamgraph we can easily see that in the first 0.8 seconds our toy
program allocates a lot of <code class="docutils literal notranslate"><span class="pre">Double</span></code>, then after 0.8 seconds <code class="docutils literal notranslate"><span class="pre">Double</span></code>
decreases and most of the heap is <code class="docutils literal notranslate"><span class="pre">[]</span></code>. You should use the streamgraph when
you want to view how a particular element in the heap changes over time.</p>
<p>The normalized linechart shows a breakdown of what is increasing over time.</p>
<p>The linecharts are noisy, fortunately we can filter to see exactly what type of
data on the heap is increasing over time. For example, here is a snapshot of the
streamgraph where I’ve filtered for <code class="docutils literal notranslate"><span class="pre">Double</span></code>:</p>
<a class="reference internal image-reference" href="../../../_images/pc_heap_linechart_double_type.png"><img alt="../../../_images/pc_heap_linechart_double_type.png" src="../../../_images/pc_heap_linechart_double_type.png" style="width: 964.8000000000001px; height: 773.6px;" /></a>
<p>Notice the triangular shape that smooths out. Here is the same plot only
filtered for <code class="docutils literal notranslate"><span class="pre">[]</span></code>:</p>
<a class="reference internal image-reference" href="../../../_images/pc_heap_linechart_list_type.png"><img alt="../../../_images/pc_heap_linechart_list_type.png" src="../../../_images/pc_heap_linechart_list_type.png" style="width: 961.6px; height: 777.6px;" /></a>
<p>Notice the roughly triangular shape. Recall that these linecharts are
<em>normalized</em> so we are not getting a raw portion of allocations on the heap,
rather the chart displays what <em>portion</em> of the heap is composed of each type.
This makes it easy to see that we actually have two memory leaks: one for
<code class="docutils literal notranslate"><span class="pre">Double</span></code> and one for <code class="docutils literal notranslate"><span class="pre">[]</span></code>. Both types show a triangular profile shape which
is a classic indication of a memory leak. It occurs because <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> builds
up a lot of thunks; increasing allocations on the heap and producing the rising
edge, the program reaches a point where the thunks must be evaluated; producing
the top of the triangle, and then begins evaluating them thus decreasing the
allocations on the heap and yielding the descending edge. We could have observed
this pattern in the other plots, but the normalized linechart directly shows it.
Use the linechart when you want to view the composition of the heap by element
over time.</p>
<p>The heap plot shows the total heap size and the block and live bytes size over
time. It is useful to see the total size of the heap at a particular time. We
present it here for our toy program but don’t comment on it further:</p>
<a class="reference internal image-reference" href="../../../_images/pc_heap_heap_type.png"><img alt="../../../_images/pc_heap_heap_type.png" src="../../../_images/pc_heap_heap_type.png" style="width: 952.8000000000001px; height: 777.6px;" /></a>
<p>The last kind of information generated by eventlog2html, the detailed view, is
one of the most useful visualizations. Here is the detailed view for the toy
program:</p>
<a class="reference internal image-reference" href="../../../_images/pc_heap_detailed_type.png"><img alt="../../../_images/pc_heap_detailed_type.png" src="../../../_images/pc_heap_detailed_type.png" style="width: 1034.4px; height: 639.2px;" /></a>
<p>The detailed view is a searchable table of the heap profile showing exactly the
total allocations attributable to the element (in this case the type), and extra
statistical information. You should use the detailed heap breakdown to inspect a
particular element of the heap profile that you might already suspect and
therefore can search. For our toy example, the detailed view is not that useful
because we can clearly see the culprits from the other views. However for a
complicated heap profile with numerous kinds of heap objects, the detailed view
provides an easy way to search and inspect a particular heap object which may be
buried in noise.</p>
</section>
<section id="adding-our-own-events">
<h2><span class="section-number">2.6.3.8. </span>Adding Our Own Events<a class="headerlink" href="#adding-our-own-events" title="Link to this heading">¶</a></h2>
<p>Thus far we have seen memory leaks coming from the types <code class="docutils literal notranslate"><span class="pre">Double</span></code> and <code class="docutils literal notranslate"><span class="pre">[]</span></code>,
but we have not yet distinguished <em>in the profile</em> between <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code>,
<code class="docutils literal notranslate"><span class="pre">stricter_mean</span></code>, and <code class="docutils literal notranslate"><span class="pre">strict_mean</span></code>. Consider these functions as different
phases of the toy program; it would be useful to have an indicator <em>in the heap
profile</em> that delineates between such phases. For example, such a marker would
allow us to say “Ah! Phase foo does excessive allocation due to leaking
<code class="docutils literal notranslate"><span class="pre">Double</span></code>”. This is the purpose of <code class="docutils literal notranslate"><span class="pre">traceMarker</span></code> and <code class="docutils literal notranslate"><span class="pre">traceMarkerIO</span></code> in
<code class="docutils literal notranslate"><span class="pre">Debug.Trace</span></code> in the base library. Both functions allow us to emit a custom
marker to the eventlog which will then be rendered by eventlog2html. We’ll
demonstrate both <code class="docutils literal notranslate"><span class="pre">traceMarker</span></code> in our functions and <code class="docutils literal notranslate"><span class="pre">traceMarkerIO</span></code> in the
main function. Furthermore, we’ll add some more <code class="docutils literal notranslate"><span class="pre">wait</span></code> statements to avoid a
collisions between markers and the y-axis. Here is the marker version of the toy
program:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Main</span><span class="w"> </span><span class="kr">where</span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Data.List</span><span class="w">              </span><span class="p">(</span><span class="nf">foldl&#39;</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">System.Random</span><span class="w">          </span><span class="p">(</span><span class="nf">mkStdGen</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">System.Random.Stateful</span><span class="w"> </span><span class="p">(</span><span class="nf">newIOGenM</span><span class="p">,</span><span class="w"> </span><span class="nf">uniformRM</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Control.Concurrent</span><span class="w">     </span><span class="p">(</span><span class="nf">threadDelay</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Control.Monad</span><span class="w">          </span><span class="p">(</span><span class="nf">replicateM</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Control.DeepSeq</span><span class="w">        </span><span class="p">(</span><span class="nf">force</span><span class="p">)</span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Debug.Trace</span><span class="w">            </span><span class="p">(</span><span class="nf">traceMarker</span><span class="p">,</span><span class="w"> </span><span class="nf">traceMarkerIO</span><span class="p">)</span>

<span class="nf">lazy_mean</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">lazy_mean</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">traceMarker</span><span class="w"> </span><span class="s">&quot;Begin: lazy_mean&quot;</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="n">ln</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="nf">stricter_mean</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">stricter_mean</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">traceMarker</span><span class="w"> </span><span class="s">&quot;Begin: stricter_mean&quot;</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="n">ln</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl&#39;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="nf">strict_mean</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">strict_mean</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">traceMarker</span><span class="w"> </span><span class="s">&quot;Begin: strict_mean&quot;</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="n">ln</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl&#39;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">wait</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">threadDelay</span><span class="w"> </span><span class="mi">100000</span>
<span class="w">  </span><span class="c1">-- create a delay at the beginning of the program, if we don&#39;t do this then</span>
<span class="w">  </span><span class="c1">-- our marker will be merged with the y-axis of the heap profile</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;Bench Initialization&quot;</span>
<span class="w">  </span><span class="c1">-- generate random test data</span>
<span class="w">  </span><span class="n">seed</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">newIOGenM</span><span class="w"> </span><span class="p">(</span><span class="n">mkStdGen</span><span class="w"> </span><span class="mi">1729</span><span class="p">)</span>
<span class="w">  </span><span class="n">test_values</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">replicateM</span><span class="w"> </span><span class="mi">500000</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">uniformRM</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">500000</span><span class="p">)</span><span class="w"> </span><span class="n">seed</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End Bench Initialization&quot;</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="c1">-- now run</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">lazy_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End lazy_mean&quot;</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">stricter_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End stricter_mean&quot;</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">strict_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End strict_mean&quot;</span>
</pre></div>
</div>
<p>We add markers in two areas: in the beginning of each function and after each
function call in main <em>including the benchmark setup</em>. Now let’s view the heap
profile:</p>
<iframe id="scaled-frame" scrolling="no" src="../../../_static/eventlog/pc_heap_marker_first.html"></iframe><p>The gray lines that have been added to the profile are our markers. The
<code class="docutils literal notranslate"><span class="pre">String</span></code> input to <code class="docutils literal notranslate"><span class="pre">traceMarker</span></code> and <code class="docutils literal notranslate"><span class="pre">traceMarkerIO</span></code> is visible by hovering
the mouse over the marker. Here is a snapshot where I’ve manually added the
labels to how the popups statically:</p>
<a class="reference internal image-reference" href="../../../_images/pc_heap_marker_first.png"><img alt="../../../_images/pc_heap_marker_first.png" src="../../../_images/pc_heap_marker_first.png" style="width: 956.0px; height: 778.4000000000001px;" /></a>
<p>We can make several important observations from this profile:</p>
<p>First, we can observe the difference in runtime between these functions by
comparing the horizontal space between the “Begin” and “End” markers. For
example, notice how close the begin and end markers are for <code class="docutils literal notranslate"><span class="pre">strict_mean</span></code>
compared to <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code>. From the x-axis we can see that <code class="docutils literal notranslate"><span class="pre">strict_mean</span></code>
finishes in about 0.1 seconds, while <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> finishes in about 0.3
seconds.</p>
<p>Second, the ascending side of the first memory leak (the first triangle) comes
surprisingly from the benchmark setup, because the marker occurs before the peak
of the triangle. We should expect some allocation at the beginning of our
program (we need to have data to operate on after all!), but the heap should
flatten out (because the test data finishes allocation) until <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> is
called.</p>
<p>Third, after the call to <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> <em>allocations decrease</em>. This is further
evidence of a memory leak in the benchmark setup. If we had all values from
<code class="docutils literal notranslate"><span class="pre">test_values</span></code> fully evaluated and in memory when <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> was first
called, then we would expect heap allocations <em>to increase</em> because we know that
<code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> is leaky. However, we observe the opposite; <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code>
<em>reduces</em> allocations until the heap levels out around 0.90 seconds and ~37M
allocations right before <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> ends. The point at which the allocations
level out, is the point when <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> finishes consuming thunks introduced
by the benchmark setup and finally performs the arithmetic computation. Thus, we
can conclude three things: First, a strict benchmark setup should allocate ~37M
on the heap, because this is the amount of allocations after <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> has
consumed all the thunks; Second, the actual wall time for a strict <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code>
<em>should</em> be around 0.1 seconds because this is the duration of time between the
point at which <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> has consumed all the thunks and when <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code>
ends. Third, notice that a known-leaky function did not appear to be leaky
because of another memory leak effectively hid it. This tells us that the memory
leak in <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> is not comparable to the leak in the benchmark sweet. For
if it were comparable then we would have observed a rising edge after the
<code class="docutils literal notranslate"><span class="pre">lazy_mean</span> <span class="pre">begin</span></code> marker.</p>
<p>Let’s fix the benchmark setup memory leak by forcing strict IO with <code class="docutils literal notranslate"><span class="pre">evaluate</span></code>
and <code class="docutils literal notranslate"><span class="pre">force</span></code> from <code class="docutils literal notranslate"><span class="pre">Control.Exception</span></code> and <code class="docutils literal notranslate"><span class="pre">Control.DeepSeq</span></code> respectively. A
simple one line change in <code class="docutils literal notranslate"><span class="pre">main</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Main</span><span class="w"> </span><span class="kr">where</span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Data.List</span><span class="w">              </span><span class="p">(</span><span class="nf">foldl&#39;</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">System.Random</span><span class="w">          </span><span class="p">(</span><span class="nf">mkStdGen</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">System.Random.Stateful</span><span class="w"> </span><span class="p">(</span><span class="nf">newIOGenM</span><span class="p">,</span><span class="w"> </span><span class="nf">uniformRM</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Control.Concurrent</span><span class="w">     </span><span class="p">(</span><span class="nf">threadDelay</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Control.Monad</span><span class="w">          </span><span class="p">(</span><span class="nf">replicateM</span><span class="p">)</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Control.Exception</span><span class="w">      </span><span class="p">(</span><span class="nf">evaluate</span><span class="p">)</span><span class="w">                                    </span><span class="c1">-- new</span>
<span class="kr">import</span><span class="w"> </span><span class="nn">Control.DeepSeq</span><span class="w">        </span><span class="p">(</span><span class="nf">force</span><span class="p">)</span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Debug.Trace</span><span class="w">            </span><span class="p">(</span><span class="nf">traceMarker</span><span class="p">,</span><span class="w"> </span><span class="nf">traceMarkerIO</span><span class="p">)</span>

<span class="c1">-- ... --</span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">wait</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">threadDelay</span><span class="w"> </span><span class="mi">100000</span>
<span class="w">  </span><span class="c1">-- create a delay at the beginning of the program, if we don&#39;t do this then</span>
<span class="w">  </span><span class="c1">-- our marker will be merged with the y-axis of the heap profile</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;Bench Initialization&quot;</span>
<span class="w">  </span><span class="c1">-- generate random test data</span>
<span class="w">  </span><span class="n">seed</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">newIOGenM</span><span class="w"> </span><span class="p">(</span><span class="n">mkStdGen</span><span class="w"> </span><span class="mi">1729</span><span class="p">)</span>
<span class="w">  </span><span class="n">test_values</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">fmap</span><span class="w"> </span><span class="n">force</span><span class="w"> </span><span class="p">(</span><span class="n">replicateM</span><span class="w"> </span><span class="mi">500000</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">uniformRM</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">500000</span><span class="p">)</span><span class="w"> </span><span class="n">seed</span><span class="p">)</span><span class="w"> </span><span class="c1">-- new</span>
<span class="w">                 </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">evaluate</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End Bench Initialization&quot;</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="c1">-- now run</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">lazy_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End lazy_mean&quot;</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">stricter_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End stricter_mean&quot;</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">strict_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End strict_mean&quot;</span>
</pre></div>
</div>
<p>which produces:</p>
<iframe id="scaled-frame" scrolling="no" src="../../../_static/eventlog/pc_heap_marker_still_leaky.html"></iframe><p>No difference! The only remaining source of possible thunks in <code class="docutils literal notranslate"><span class="pre">test_values</span></code>
is <code class="docutils literal notranslate"><span class="pre">uniformRM</span></code> and the generation of <code class="docutils literal notranslate"><span class="pre">seed</span></code>. So we’ll remove any possible
lazy IO from that call:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">wait</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">threadDelay</span><span class="w"> </span><span class="mi">100000</span>
<span class="w">  </span><span class="c1">-- create a delay at the beginning of the program, if we don&#39;t do this then</span>
<span class="w">  </span><span class="c1">-- our marker will be merged with the y-axis of the heap profile</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;Bench Initialization&quot;</span>
<span class="w">  </span><span class="c1">-- generate random test data</span>
<span class="w">  </span><span class="o">!</span><span class="n">seed</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">newIOGenM</span><span class="w"> </span><span class="p">(</span><span class="n">mkStdGen</span><span class="w"> </span><span class="mi">1729</span><span class="p">)</span><span class="w">                                       </span><span class="c1">-- new</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">genValue</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fmap</span><span class="w"> </span><span class="n">force</span><span class="w"> </span><span class="n">uniformRM</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">500000</span><span class="p">)</span><span class="w"> </span><span class="n">seed</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">evaluate</span><span class="w">         </span><span class="c1">-- new</span>
<span class="w">  </span><span class="n">test_values</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">replicateM</span><span class="w"> </span><span class="mi">50000</span><span class="w"> </span><span class="n">genValue</span><span class="w">            </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">force</span><span class="w"> </span><span class="c1">-- new</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End Bench Initialization&quot;</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="c1">-- now run</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">lazy_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End lazy_mean&quot;</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">stricter_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End stricter_mean&quot;</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">strict_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End strict_mean&quot;</span>
</pre></div>
</div>
<p>which produces an empty heap profile!:</p>
<iframe id="scaled-frame" scrolling="no" src="../../../_static/eventlog/pc_heap_marker_empty.html"></iframe><p>The profile is empty because our sampling rate is too low now that we’ve removed
those thunks. Let’s sample 100x more frequently by setting the <code class="docutils literal notranslate"><span class="pre">-i</span></code> RTS flag.
The invocation now becomes:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>cabal<span class="w"> </span>bench<span class="w"> </span>pointerChasing<span class="w"> </span>--benchmark-options<span class="o">=</span><span class="s1">&#39;+RTS -hy -l-agu -i0.001</span>
<span class="s1">-RTS&#39;</span><span class="p">;</span><span class="w"> </span>eventlog2html<span class="w"> </span>pointerChasing.eventlog<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>firefox<span class="w"> </span>pointerChasing.eventlog.html
</pre></div>
</div>
<p>and produces this heap profile:</p>
<iframe id="scaled-frame" scrolling="no" src="../../../_static/eventlog/pc_heap_marker_high_sample.html"></iframe><p>Much better! There are several things to point out. The y-axis has reduced to
~7M maximum, and the x-axis has also reduced from 1.8 seconds to 0.9 seconds. We
can clearly see the memory leaks from <code class="docutils literal notranslate"><span class="pre">lazy</span></code> and <code class="docutils literal notranslate"><span class="pre">stricter</span></code> now. In fact,
<code class="docutils literal notranslate"><span class="pre">lazy</span></code> has a total of three memory leaks, and <code class="docutils literal notranslate"><span class="pre">stricter</span></code> has two. Because
our program is relatively simple, there are not many sites where these leaks
could originate. We’ll focus on <code class="docutils literal notranslate"><span class="pre">stricter_mean</span></code> and add markers to the source
of the remaining leaks. We’ll also remove <code class="docutils literal notranslate"><span class="pre">lazy_mean</span></code> but keep <code class="docutils literal notranslate"><span class="pre">strict_mean</span></code>
for comparison . Here is <code class="docutils literal notranslate"><span class="pre">stricter_mean</span></code> reproduced to refresh your memory:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">stricter_mean</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">stricter_mean</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">traceMarker</span><span class="w"> </span><span class="s">&quot;Begin: stricter_mean&quot;</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="n">ln</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl&#39;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>We observed two leaks. We know that the fold should produce one leak because
<code class="docutils literal notranslate"><span class="pre">foldl'</span></code> evaluates the accumulator to weak head normal form, and the <code class="docutils literal notranslate"><span class="pre">step</span></code>
function does not evaluate the values inside its input <code class="docutils literal notranslate"><span class="pre">(,)</span></code>, thus
accumulating thunks in the elements of the tuple. Let’s add markers to verify
this behavior:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">stricter_mean</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">stricter_mean</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">traceMarker</span><span class="w"> </span><span class="s">&quot;s&quot;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="p">(</span><span class="n">traceMarker</span><span class="w"> </span><span class="s">&quot;ln&quot;</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl&#39;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>which yields:</p>
<iframe id="scaled-frame" scrolling="no" src="../../../_static/eventlog/pc_heap_marker_s_ln.html"></iframe><p>Now we can see that the call to <code class="docutils literal notranslate"><span class="pre">ln</span></code> reduces a lot of the heap. Let’s make
<code class="docutils literal notranslate"><span class="pre">ln</span></code> strict in <code class="docutils literal notranslate"><span class="pre">step</span></code> and observe the difference in the heap profile:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">stricter_mean</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">stricter_mean</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">traceMarker</span><span class="w"> </span><span class="s">&quot;s&quot;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="p">(</span><span class="n">traceMarker</span><span class="w"> </span><span class="s">&quot;ln&quot;</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl&#39;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>and now we have:</p>
<iframe id="scaled-frame" scrolling="no" src="../../../_static/eventlog/pc_heap_marker_strict_ln.html"></iframe><p>Notice the y-axis has further reduced and that the marker for <code class="docutils literal notranslate"><span class="pre">ln</span></code> has
disappeared. The marker is still in the profile (you can check the <code class="docutils literal notranslate"><span class="pre">eventlog</span></code>
file), but because <code class="docutils literal notranslate"><span class="pre">ln</span></code> doesn’t force any thunks the marker is shadowed by the
<code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">stricter_mean</span></code> marker. We still have a leak after <code class="docutils literal notranslate"><span class="pre">s</span></code>, but this was
expected. Let’s make sure this is coming from <code class="docutils literal notranslate"><span class="pre">s</span></code> by making <code class="docutils literal notranslate"><span class="pre">s</span></code> strict:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">stricter_mean</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Double</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span>
<span class="nf">stricter_mean</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">traceMarker</span><span class="w"> </span><span class="s">&quot;s&quot;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fromIntegral</span><span class="w"> </span><span class="p">(</span><span class="n">traceMarker</span><span class="w"> </span><span class="s">&quot;ln&quot;</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span>
<span class="w">  </span><span class="kr">where</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span><span class="w">        </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl&#39;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>
<span class="w">        </span><span class="n">step</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="n">ln</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ln</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>which yields:</p>
<iframe id="scaled-frame" src="../../../_static/eventlog/pc_heap_marker_strict_s_ln.html"></iframe><p><code class="docutils literal notranslate"><span class="pre">stricter_mean</span></code> still doesn’t run in constant heap as the heap decreases
during and after calling it, but it is difficult to see exactly what is
decreasing. This situation is exactly why the detailed heap view is useful.
Checking the detailed view of the latest profile shows <code class="docutils literal notranslate"><span class="pre">Double</span></code> and <code class="docutils literal notranslate"><span class="pre">[]</span></code> to
be constant, but shows <code class="docutils literal notranslate"><span class="pre">*</span></code> decreasing. <code class="docutils literal notranslate"><span class="pre">*</span></code> is the symbol the heap profiler
emits for closures that have an unknown type. But the toy program is completely
monomorphic and has known types, so where do we have an unknown type? The only
code in the toy program that doesn’t have a precise type is in the benchmark
setup, and specifically this line:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="nf">seed</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">newIOGenM</span><span class="w"> </span><span class="p">(</span><span class="n">mkStdGen</span><span class="w"> </span><span class="mi">1729</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">newIOGenM</span></code> returns a polymorphic type that is implemented as an
<code class="docutils literal notranslate"><span class="pre">IORef</span></code>, that is, a value the profiler doesn’t have access to! Thus, forcing
this value should remove the memory leak. Our final <code class="docutils literal notranslate"><span class="pre">main</span></code> is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">wait</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">threadDelay</span><span class="w"> </span><span class="mi">100000</span>
<span class="w">  </span><span class="c1">-- create a delay at the beginning of the program, if we don&#39;t do this then</span>
<span class="w">  </span><span class="c1">-- our marker will be merged with the y-axis of the heap profile</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;Bench Initialization&quot;</span>
<span class="w">  </span><span class="c1">-- generate random test data</span>
<span class="w">  </span><span class="o">!</span><span class="n">seed</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">newIOGenM</span><span class="w"> </span><span class="p">(</span><span class="n">mkStdGen</span><span class="w"> </span><span class="mi">1729</span><span class="p">)</span><span class="w">                               </span><span class="c1">-- new</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">genValue</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fmap</span><span class="w"> </span><span class="n">force</span><span class="w"> </span><span class="n">uniformRM</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">500000</span><span class="p">)</span><span class="w"> </span><span class="n">seed</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">evaluate</span>
<span class="w">  </span><span class="n">test_values</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">replicateM</span><span class="w"> </span><span class="mi">50000</span><span class="w"> </span><span class="n">genValue</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">force</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End Bench Initialization&quot;</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;Begin stricter_mean&quot;</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">stricter_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End stricter_mean&quot;</span>
<span class="w">  </span><span class="n">wait</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="o">$!</span><span class="w"> </span><span class="n">strict_mean</span><span class="w"> </span><span class="n">test_values</span>
<span class="w">  </span><span class="n">traceMarkerIO</span><span class="w"> </span><span class="s">&quot;End strict_mean&quot;</span>
</pre></div>
</div>
<p>which produces the final heap profile:</p>
<p>We could further investigate but our heap is now constant across
<code class="docutils literal notranslate"><span class="pre">stricter_mean</span></code> validating the lazy tuple hypothesis.</p>
<iframe id="scaled-frame" src="../../../_static/eventlog/pc_heap_marker_final.html"></iframe></section>
<section id="summary">
<h2><span class="section-number">2.6.3.9. </span>Summary<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>In sum, we’ve demonstrated heap profiling using GHC’s eventlog and
<a class="reference external" href="https://mpickering.github.io/eventlog2html/">eventlog2html</a>. Eventlog records event specific data produced by GHC as a
function of walltime. One can embed and emit custom events using the functions
<code class="docutils literal notranslate"><span class="pre">traceEvent</span></code> and <code class="docutils literal notranslate"><span class="pre">traceEventIO</span></code>, and add runtime markers to the eventlog
with <code class="docutils literal notranslate"><span class="pre">traceMarker</span></code> and <code class="docutils literal notranslate"><span class="pre">traceMarkerIO</span></code> in base. These functions and the
better visualizations of <a class="reference external" href="https://mpickering.github.io/eventlog2html/">eventlog2html</a> make eventlog a powerful tool when
investigating the runtime behavior of a program. In particular when finding,
fixing, and debugging memory leaks or when correlating heap information to a
particular function or phase of the program.</p>
</section>
<section id="references-and-further-reading">
<h2><span class="section-number">2.6.3.10. </span>References and Further Reading<a class="headerlink" href="#references-and-further-reading" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>The eventlog section in the <a class="reference external" href="https://downloads.haskell.org/~ghc/9.2.4/docs/html/users_guide/runtime_control.html#rts-eventlog">GHC User’s
Guide</a>.</p></li>
<li><p>The eventlog2html <a class="reference external" href="https://mpickering.github.io/eventlog2html/">home page</a>.</p></li>
</ol>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="info_table.html"
       title="previous chapter">← <span class="section-number">2.6.2. </span><span class="lightgrey">Info-Table Profiling</span></a>
  </li>
  <li class="next">
    <a href="criterion.html"
       title="next chapter"><span class="section-number">2.6.4. </span><span class="lightgrey">Criterion, Gauge, and Tasty-Bench</span> →</a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; Copyright 2022-2024, Jeffrey Young (doyougnu).
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.2.6 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>