<!DOCTYPE html>
<html  lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

      <title>2.1. The Recipe</title>
    
          <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/theme.css " type="text/css" />
          <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/css/s4defs-roles.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/css/iframe.css" type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../../_static/theme-vendors.js"></script> -->
      <script src="../../_static/theme.js" defer></script>
    
  <link rel="index" title="Index" href="../../genindex.html" />
  <link rel="search" title="Search" href="../../search.html" />
  <link rel="next" title="2.2. Heap Profiling and Inspection : GHC Based Methods" href="Heap_Ghc/index.html" />
  <link rel="prev" title="2. Measurement, Profiling, and Observation" href="index.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../contents.html" class="home-link">
    
      <span class="site-name">Haskell Optimization Handbook</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">

  
    <div class="nav-item">
      <a href="../../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../../contents.html#indices-and-tables"
         class="nav-link ">
         indices and tables
      </a>
    </div>
  



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            

  
    <div class="nav-item">
      <a href="../../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../../contents.html#indices-and-tables"
         class="nav-link ">
         indices and tables
      </a>
    </div>
  



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Quick search</span>
    <div class="searchformwrapper">
      <form class="search" action="../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Search" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../contents.html#haskell-optimization-handbook">Table of Contents</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../Preliminaries/index.html" class="reference internal ">Preliminaries</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="index.html" class="reference internal ">Measurement, Profiling, and Observation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Optimizations/index.html" class="reference internal ">Optimizations</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Case_Studies/index.html" class="reference internal ">Case Studies</a>
            

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../contents.html#indices-and-tables">indices and tables</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../glossary.html" class="reference internal ">Glossary</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../contents.html">Docs</a> &raquo;</li>
    
      <li><a href="index.html"><span class="section-number">2. </span>Measurement, Profiling, and Observation</a> &raquo;</li>
    
    <li><span class="section-number">2.1. </span>The Recipe</li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="index.html"
       title="previous chapter">← <span class="section-number">2. </span>Measurement, Profiling, and Observation</a>
  </li>
  <li class="next">
    <a href="Heap_Ghc/index.html"
       title="next chapter"><span class="section-number">2.2. </span>Heap Profiling and Inspection : GHC Based Methods →</a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="the-recipe">
<h1><span class="section-number">2.1. </span>The Recipe<a class="headerlink" href="#the-recipe" title="Permalink to this heading">¶</a></h1>
<div class="admonition warning" id="don-t-think-look">
<span id="understand-the-system"></span><p class="admonition-title">Warning</p>
<p>This chapter is going to be rewritten with reference to David Agan’s
<a class="reference external" href="https://debuggingrules.com/">Debugging book</a>. Until that time, I have left
it intact in case it may be helpful. If you came here chasing a link to
<code class="docutils literal notranslate"><span class="pre">understand</span> <span class="pre">the</span> <span class="pre">system</span></code> or <code class="docutils literal notranslate"><span class="pre">don't</span> <span class="pre">think,</span> <span class="pre">look</span></code>, then I refer you to his
book for the time being.</p>
</div>
<p>This chapter presents a recipe for debugging performance regressions in Haskell.
Often, when we debug code, it becomes too easy to trace execution or use a
shotgun approach; we apply a bunch of best-guess changes and retest to see if
our stimulus presents a response. You should do your best to avoid these urges.
Instead, use a scientific approach and develop a hypothesis and conceptual model
of the failure mode or bug. Every bug or performance regression is a learning
opportunity and should be considered as such. By treating regressions as
learning opportunities, you gain knowledge of your system and the systems it
interacts with, and in turn, become a better software engineer. This chapter
provides a sequence of questions and reminders to help you take a scientific
approach to performance regression debugging. We hope it aids you well.</p>
<section id="vocabulary">
<h2><span class="section-number">2.1.1. </span>Vocabulary<a class="headerlink" href="#vocabulary" title="Permalink to this heading">¶</a></h2>
<p>Unless otherwise noted, we use the following vocabulary to describe various
aspects of our optimization journey. Because these do not have a formal
definition, we present them here instead of in the <a class="reference internal" href="../glossary.html#glossary"><span class="std std-ref">Glossary</span></a>:</p>
<ol class="arabic simple">
<li><p><em>The system</em>: The system is the local infrastructure and computational
edifice your program operates in. This includes your operating system, your
CPU, your memory controller.</p></li>
<li><p><em>The program</em>: The program is the program we are trying to optimize that runs
on the system.</p></li>
<li><p><em>The problem</em>: The problem is an observable phenomenon of the program. It is
the performance regression we are trying to characterize, understand, fix and
prevent.</p></li>
<li><p><em>The failure mode</em>: The failure mode is the sequence of interactions between
sub-systems or external systems and your system that manifest the problem.</p></li>
<li><p><em>The baseline</em>: The baseline is the observable, measurable behavior of the
program which constitutes <em>normal operation</em>. This is how you know you have a
problem.</p></li>
</ol>
</section>
<section id="characterize-the-problem">
<span id="id1"></span><h2><span class="section-number">2.1.2. </span>Characterize the Problem<a class="headerlink" href="#characterize-the-problem" title="Permalink to this heading">¶</a></h2>
<p>The first step to solving any kind of problem is characterization. The goal of
this step is to observe how the problem <em>presents</em> itself in the system in terms
of the sub-systems the system uses. No phenomenon exists without leaving a trail
of evidence, and our purpose in this step is to find this trail and re-state the
problem description <em>in terms</em> of the system. You should begin by asking
yourself the following questions:</p>
<ol class="arabic simple">
<li><p>Have I observed this problem before? Is it a known failure mode? If so, then
why does it continue to happen? What are the chain of events that have caused
it to occur again?</p></li>
<li><p>Is the problem deterministic? Or is it stochastic? If it is stochastic, what
is the rate at which we observe the problem phenomenon?</p></li>
<li><p>Is there anything <em>unique</em> about the environment the problem manifests in?
Specifically:
-. Does it manifest only on unique hardware?
-. Does it manifest at a particular time of day or only on one person’s machine?
-. Does it manifest only when other processes are running?</p></li>
<li><p>Is the problem temporal? Has anything <em>recently</em> changed in the system or the
environment the system operates in that could induce the problem? Bring out
the git logs and begin bisecting!</p></li>
</ol>
<section id="precisely-restate-the-problem">
<h3><span class="section-number">2.1.2.1. </span>Precisely Restate the Problem<a class="headerlink" href="#precisely-restate-the-problem" title="Permalink to this heading">¶</a></h3>
<p>With these questions in mind, the next step is to gather data <a class="footnote-reference brackets" href="#id4" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> . You want to
gather enough data to be able to precisely describe the problem in terms of
metrics your system cares about. For example, in a high performance application
our system likely cares about any decrease in instructions per cycle (IPC) of
our CPU. So IPC is a useful metric to measure, in order to characterize the
problem by comparing the IPC on the problem input to the IPC of normal
operation. Other examples might be an increase in total CPU cycles, runtime
memory cost, missed branches, cache writes/reads misses, network requests,
dropped packets etc. Whatever the metric, the key point is that the problem <em>can
be observed</em> through a change in the metric compared to baseline.</p>
<p>Next we require a good description of the problem. “The system slows to a crawl”
is not a good description of the problem because it is too vague. How does the
system slow? At what point does it slow? On what input does it slow? Does this
always happen or is it a random occurrence? “The system consumes 36Gb out of
32Gb of memory on input <code class="docutils literal notranslate"><span class="pre">foo</span></code>, after 4 seconds.” is a good description of the
problem. It is a precise description; we know that whatever the root cause is,
it affects the runtime memory of our program and that the problem manifests at a
certain point during runtime. Additionally, this is a good description because
gives an estimate of the magnitude of the problem <em>in terms</em> of a metric our
system cares about, e.g., runtime memory, and because it identifies a sub-system
(the heap) in the failure mode.</p>
<p>This step is concluded when you are able to precisely restate the problem in
terms of metrics that are meaningful to your system.</p>
</section>
</section>
<section id="construct-a-hypothetical-failure-mode">
<h2><span class="section-number">2.1.3. </span>Construct a Hypothetical Failure Mode<a class="headerlink" href="#construct-a-hypothetical-failure-mode" title="Permalink to this heading">¶</a></h2>
<p>The next step is to construct a hypothetical failure mode that could produce the
observed problem. The failure mode should be a statement of sub-system
interactions.  Imagine walking through the system with
the data. At each step write down a description of events that happen to the
data and where the events occurred. For example, here is a possible failure mode
for high amounts of heap use:</p>
<blockquote>
<div><p>The system receives input <code class="docutils literal notranslate"><span class="pre">Foo</span></code> from the command line. <code class="docutils literal notranslate"><span class="pre">Foo</span></code> is validated
as legal by <code class="docutils literal notranslate"><span class="pre">parseUserInput</span></code> and marked as such in the type system with the
<code class="docutils literal notranslate"><span class="pre">Legal</span></code> newtype. The worker function <code class="docutils literal notranslate"><span class="pre">fib</span></code> is applied to <code class="docutils literal notranslate"><span class="pre">Legal</span> <span class="pre">Foo</span></code>.
<code class="docutils literal notranslate"><span class="pre">fib</span></code> unpacks <code class="docutils literal notranslate"><span class="pre">Legal</span> <span class="pre">Foo</span></code> to receive a raw input of 1729. <code class="docutils literal notranslate"><span class="pre">fib</span></code> begins
computing and we observe the problem.</p>
</div></blockquote>
<p>Of course, this is a toy example and the failure mode in a large complex system
may be very long. If this is the case then begin writing the failure mode in
broad strokes, e.g.:</p>
<blockquote>
<div><p>Input <code class="docutils literal notranslate"><span class="pre">Foo</span></code> is input to the system, it then propagates to sub-system
<code class="docutils literal notranslate"><span class="pre">Bar</span></code>, is changed to <code class="docutils literal notranslate"><span class="pre">FooFoo</span></code> and then propagates to sub-system <code class="docutils literal notranslate"><span class="pre">Baz</span></code>.</p>
</div></blockquote>
<p>In this style, you are not overly concerned with the exact functions that do the
work. Rather, you are simply laying out the path the problem input takes through
the system. You can fill in the details as you gain insight into the failure
mode through testing.</p>
<p>This step is concluded when you have identified and written down one or more
hypothetical failure modes.</p>
</section>
<section id="create-the-smallest-reproducible-test-of-the-problem">
<h2><span class="section-number">2.1.4. </span>Create the Smallest Reproducible Test of the Problem<a class="headerlink" href="#create-the-smallest-reproducible-test-of-the-problem" title="Permalink to this heading">¶</a></h2>
<p>Once you have characterized the problem and identified possible failure modes, you
should try to create an isolated, minimal test to reproduce the problem. The
idea is to capture the problem so you can begin analyzing it. A test is a
light switch; the ideal outcome of this step is that you have a light switch
where you can “turn on” and “turn off” the problem at will. Try to construct the
test such that it interacts with as few sub-systems and external systems as
possible to limit the scope of the investigation. At the end of the
investigation, you can add this test to your test suite to ensure the problem
does not manifest again. If you have many possible failure modes, try to
have one test per failure mode.</p>
<p>Creating a reproducible test is never the easy part, but it is not impossible.
To construct the test case, try the following steps:</p>
<ol class="arabic simple">
<li><p>Try to isolate the sub-systems and external systems that you suspect are
likely to be in the failure mode or failure modes.</p></li>
<li><p>Each external system provides information or a service to your system. Try to
reproduce these dependencies in a deterministic way and treat them as inputs
to your test case.</p></li>
<li><p>Try to isolate the code you believe to be in the failure mode. This should
follow almost directly from characterizing the problem and defining the
failure mode or modes. Tools such as Valgrind, which provide line by line
information of source code, are helpful here if CPU cycle counts are a
meaningful metric for your system.</p></li>
<li><p>Remove all domain-specific information. Think of the possible failure mode
from the perspective of the system. Do not think in terms of your business
logic; using concepts such as <code class="docutils literal notranslate"><span class="pre">Customer</span></code>, <code class="docutils literal notranslate"><span class="pre">Bank</span> <span class="pre">Account</span></code>, or <code class="docutils literal notranslate"><span class="pre">Payment</span>
<span class="pre">Information</span></code>. Instead, think in terms of the realization of these concepts
in your system. <code class="docutils literal notranslate"><span class="pre">Customer</span></code> is a <code class="docutils literal notranslate"><span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">Bank</span> <span class="pre">Account</span></code> is an
<code class="docutils literal notranslate"><span class="pre">Integer</span></code>, <code class="docutils literal notranslate"><span class="pre">Payment</span> <span class="pre">information</span></code> is a <code class="docutils literal notranslate"><span class="pre">Text</span></code>. Now re-describe the
failure mode in terms of the implementation: “When I send sub-system <code class="docutils literal notranslate"><span class="pre">Foo</span></code>
a <code class="docutils literal notranslate"><span class="pre">String</span></code> that contains the character <code class="docutils literal notranslate"><span class="pre">U+03BB</span></code>, I observe the problem”.</p></li>
<li><p>Create slightly different tests to test different code paths of the failure
mode. Run tests to see if you can deterministically observe the problem. You
should be able to state “When I input <code class="docutils literal notranslate"><span class="pre">Foo</span></code> with properties <code class="docutils literal notranslate"><span class="pre">Bar</span></code>, I
observe the problem”, and “When I input <code class="docutils literal notranslate"><span class="pre">Baz</span></code> with properties <code class="docutils literal notranslate"><span class="pre">Qux</span></code>, I
observe the baseline”. You know you have found the right code path in the
failure mode when you can reproducibly force the problem to occur <em>and</em> not to
occur.</p></li>
</ol>
</section>
<section id="define-a-hypothesis">
<h2><span class="section-number">2.1.5. </span>Define a Hypothesis<a class="headerlink" href="#define-a-hypothesis" title="Permalink to this heading">¶</a></h2>
<section id="the-objects-of-the-hypothesis">
<h3><span class="section-number">2.1.5.1. </span>The Objects of the Hypothesis<a class="headerlink" href="#the-objects-of-the-hypothesis" title="Permalink to this heading">¶</a></h3>
<p>Think of each sub-system, external system, and component of your system as
characters in a story. Any system that takes an action to produce a result that
your code interacts with or causes is a character. Each data structure your
code directly or indirectly uses is a character. Each function you have
written is a character; and so on. These are the objects of your hypothesis;
they are what the hypothesis makes a statement about and define the sequence of
interactions that constitutes the failure mode.</p>
</section>
<section id="defining-a-good-hypothesis">
<h3><span class="section-number">2.1.5.2. </span>Defining a Good Hypothesis<a class="headerlink" href="#defining-a-good-hypothesis" title="Permalink to this heading">¶</a></h3>
<p>Of course, not all hypotheses are equal. Good hypotheses have the following
properties:</p>
<ol class="arabic simple">
<li><p>They make progress, i.e., they are <em>falsifiable</em>; a good hypothesis yields
information when confirmed <em>and</em> when invalidated. A bad hypothesis <em>keeps
constant</em> the level of information you have about the phenomena. In other
words, a bad hypothesis is one where you only gain information if the
hypothesis is validated, not when the hypothesis is either validated <em>or</em> invalidated.</p></li>
<li><p>They are <em>specific and testable</em>: Good hypotheses are specific enough <em>to be</em>
invalidated. For example, the hypothesis “The total runtime of the system is
dominated by garbage collection induced by storing thunks in the cache” is
testable; we can directly measure how much garbage collection the runtime
system does and the kinds of objects it is storing (see <a class="reference internal" href="Heap_Ghc/ghc_flags.html"><span class="doc">GHC Flags</span></a>). This hypothesis is also specific; from reading it
we know which sub-systems to inspect: the garbage collector, the cache, and
the heap. But in addition to that, this hypothesis also adds information
<em>even if</em> it is shown to be wrong. It could be the case that the runtime <em>is
not</em> dominated by garbage collection, or it could be the case that the cache
<em>is not</em> storing thunks. Either way, by testing and invalidating the
hypothesis we learn where runtime is spent, and what is stored in the cache.</p></li>
</ol>
</section>
</section>
<section id="predict-the-response-and-test">
<h2><span class="section-number">2.1.6. </span>Predict the Response and Test<a class="headerlink" href="#predict-the-response-and-test" title="Permalink to this heading">¶</a></h2>
<p>Now that you have a hypothesis, a hypothetical failure mode, and a minimal test
case, you can begin testing. Each change made to your code should be
in pursuit of validating or invalidating the hypothesis. Do your best to resist
the urge to begin shotgun debugging! <a class="footnote-reference brackets" href="#id5" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> The workflow should be:</p>
<ol class="arabic simple">
<li><p>Review the hypothesis and predict the response. State “if the hypothesis is
true, then <code class="docutils literal notranslate"><span class="pre">Foo</span></code> should happen, or I should observe <code class="docutils literal notranslate"><span class="pre">Bar</span></code>”.</p></li>
<li><p>Review the test to make sure the test will test the hypothesis and the
failure mode.</p></li>
<li><p>Perform your changes in the system. These should be <em>minimal</em>, ideally only a
single change.</p></li>
<li><p>Observe the response and then try to make sense of the response in comparison
to the hypothesis.</p></li>
<li><p>Repeat. Iterate until you have focused down the failure mode and the
hypothesis.</p></li>
</ol>
</section>
<section id="summary">
<h2><span class="section-number">2.1.7. </span>Summary<a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>Be sure to have a reproducible testing environment set up before you begin
gathering data. <a class="reference internal" href="../Preliminaries/repeatable_measurements.html#repeatable-measurements"><span class="std std-ref">Setting up a Reproducible Test Environment</span></a></p>
</aside>
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>Shotgun debugging is usually an indication that you have not properly
characterized the problem. The need to shotgun debug comes from not
having identified the failure mode of the problem yet. In essence, when
you shotgun debug, you add a bunch of stimulus into the system hoping for
a response. If you get a response (the problem phenomena has changed)
then you know you have stumbled upon the failure mode of the problem. If
you do not get a response, then you know that the sub-systems you’ve
altered are not in the failure mode of the problem. This search for the
failure mode is characterization of the problem and thus, so is shotgun
debugging.</p>
</aside>
</aside>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="index.html"
       title="previous chapter">← <span class="section-number">2. </span>Measurement, Profiling, and Observation</a>
  </li>
  <li class="next">
    <a href="Heap_Ghc/index.html"
       title="next chapter"><span class="section-number">2.2. </span>Heap Profiling and Inspection : GHC Based Methods →</a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; Copyright 2022-2023, Jeffrey Young (doyougnu).
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.1.1 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>