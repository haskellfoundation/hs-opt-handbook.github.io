<!DOCTYPE html>
<html  lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="viewport" content="width=device-width, initial-scale=1" />

      <title>1.3. Philosophies of Optimization</title>
    
          <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/theme.css " type="text/css" />
          <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/css/s4defs-roles.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/css/iframe.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/css/admonitions.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/css/s4defs-roles.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/css/iframe.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/css/admonitions.css" type="text/css" />
      
      <!-- sphinx script_files -->
        <script src="../../_static/documentation_options.js?v=d45e8c67"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../../_static/theme-vendors.js"></script> -->
      <script src="../../_static/theme.js" defer></script>
    
  <link rel="index" title="Index" href="../../genindex.html" />
  <link rel="search" title="Search" href="../../search.html" />
  <link rel="next" title="1.5. The Golden Rules of Performance-Oriented Haskell" href="golden_rules.html" />
  <link rel="prev" title="1.2. The Programs of Consistent Lethargy" href="what_makes_fast_hs.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../contents.html" class="home-link">
    
      <span class="site-name">Haskell Optimization Handbook</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">

  
    <div class="nav-item">
      <a href="../../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../../contents.html#indices-and-tables"
         class="nav-link ">
         indices and tables
      </a>
    </div>
  



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            

  
    <div class="nav-item">
      <a href="../../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../../contents.html#indices-and-tables"
         class="nav-link ">
         indices and tables
      </a>
    </div>
  



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Quick search</span>
    <div class="searchformwrapper">
      <form class="search" action="../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Search" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../contents.html#haskell-optimization-handbook">Table of Contents</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="index.html" class="reference internal ">Preliminaries</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Measurement_Observation/index.html" class="reference internal ">Measurement, Profiling, and Observation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Optimizations/index.html" class="reference internal ">Optimizations</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Case_Studies/index.html" class="reference internal ">Case Studies</a>
            

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../contents.html#indices-and-tables">indices and tables</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../glossary.html" class="reference internal ">Glossary</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../contents.html">Docs</a> &raquo;</li>
    
      <li><a href="index.html"><span class="section-number">1. </span>Preliminaries</a> &raquo;</li>
    
    <li><span class="section-number">1.3. </span>Philosophies of Optimization</li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="what_makes_fast_hs.html"
       title="previous chapter">← <span class="section-number">1.2. </span>The Programs of Consistent Lethargy</a>
  </li>
  <li class="next">
    <a href="golden_rules.html"
       title="next chapter"><span class="section-number">1.5. </span><span class="lightgrey">The Golden Rules of Performance-Oriented Haskell</span> →</a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="philosophies-of-optimization">
<span id="philosophies-of-optimization-chapter"></span><h1><span class="section-number">1.3. </span>Philosophies of Optimization<a class="headerlink" href="#philosophies-of-optimization" title="Link to this heading">¶</a></h1>
<p>What does it mean to optimize a code base? What is optimization? If we do not
understand what it means to optimize, then how can we possibly optimize a code
base? In this chapter, we present philosophies of optimization to answers these
questions. These ideas hail from the performance oriented culture of video game
developers <a class="footnote-reference brackets" href="#id7" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, we’ve only summarized them here.</p>
<p>There are three philosophies of optimization, they are:</p>
<section id="optimization">
<span id="id2"></span><h2><span class="section-number">1.3.1. </span>Optimization<a class="headerlink" href="#optimization" title="Link to this heading">¶</a></h2>
<p>This is actual optimization, the idea is to change the implementation to target
a <em>specific</em> machine or kind of machine. The following tasks are optimization
tasks:</p>
<ol class="loweralpha simple">
<li><p>Checking the specifications of the machine to determine how fast the machine
can do the mathematical operations the workload and program implementation
require.</p></li>
<li><p>Inspecting the operations the program is required to do to ensure they are
optimal for the machine the implementation will run on. For example, altering
the implementation to avoid specific assembly instructions such as <code class="docutils literal notranslate"><span class="pre">jmp</span></code>
and instead generating <code class="docutils literal notranslate"><span class="pre">cmov</span></code>.</p></li>
<li><p>Ensuring that the algorithm the code implements is optimal for the
workload.</p></li>
<li><p>Benchmarking the implementation and comparing the results to the theoretical
maximum the machine is capable of, and then inspecting the implementation’s
runtime to determine where exactly the program slows down.</p></li>
</ol>
<p>An example of optimization in Haskell would be tuning the runtime system flags
to the machine the program will run on. For example, building the program with
no-tables-next-to-code because we have measured that tables-next-to-code
<a class="reference internal" href="../Measurement_Observation/Binary_Profiling/linux_perf.html#checking-the-l1-cache"><span class="std std-ref">increases L1 cache-misses</span></a> for the machine we
intend to run on production.</p>
<p>Actual optimization is hard and time consuming. There is a time and place for
it, but it should not be the bulk of your optimization work in normal
circumstances because its benefits are overly specific to one kind of machine.
So in the general case, where you are writing software that runs on machines you
don’t know anything about, you should instead optimize via non-pessimization.</p>
</section>
<section id="non-pessimization">
<span id="id3"></span><h2><span class="section-number">1.3.2. </span>Non-Pessimization<a class="headerlink" href="#non-pessimization" title="Link to this heading">¶</a></h2>
<p>Non-pessimization is a philosophy of crafting software where one tries to write
software that does the least amount of work possible. Or in other words, this
philosophy asks us to write code that minimizes extra work the CPU must do. The
idea behind non-pessimization is that modern hyperscaler pipelining CPUs are
extremely fast, and by <em>not</em> burdening the CPU with extra work, the
implementation will necessarily be performant.</p>
<p>A typical example of pessimized code that Haskellers’ should be familiar with is
an excessive use of laziness for a workload that simply does not require the
laziness. For example, computing the sum of an input list with a lazy
accumulator. This is an example of pessimized code because the code is
requesting the CPU do extra non-necessary work. That work being the allocating
thunks, and then searching for thunks distributed all about the heap. Of course
each thunk will and must be eventually scrutinized, but conceptually the
workload does not benefit from and does not require laziness. Thus the
construction and eventual scrutinization of these thunks is simply wasted time
and effort placed onto the CPU.</p>
<p>Key to this approach is keeping in mind what the machine must do in order to
complete the work load that your program defines. Once you have grokked this
thinking, writing code that does the least amount of work will follow. In the
previous example of lazy accumulation, the author of that code was not thinking
in terms of the machine. Had they been thinking in terms of the operations the
machine must perform, then they would have observed that the thunks were
superfluous to the requisite workload.</p>
<p>Some more examples of pessimized code are:</p>
<ol class="loweralpha">
<li><p>Too much polymorphism and higher ordered functions. In general, anything that
could add an <a class="reference internal" href="../glossary.html#term-Unknown-function"><span class="xref std std-term">Unknown Function</span></a> to hot loops that we care about is, and
will be unnecessary work for the CPU.</p></li>
<li><p>Using lot’s of libraries with code that you do not understand and have not
benchmarked. Libraries will prioritize whatever the library author felt was
important. Note that If one of those things is performance, and you find (by
empirically measuring) that the library is suitably performant for your
workload then by all means use it. The point being that you should be
deliberate and selective with your dependencies and should empirically assess
them.</p></li>
<li><p>Excessive use of Constructors and fancy types <a class="footnote-reference brackets" href="#id8" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. For non-pessimized code
we want to do <em>as little</em> as possible. This certainly means avoiding the
creation of a lot of objects that live all over the heap.</p></li>
<li><p>Defining types with poor memory efficiency. Consider this example from
GHC’s STG implementation:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">LambdaFormInfo</span>
<span class="ow">=</span>
<span class="o">...</span>
<span class="o">|</span><span class="w"> </span><span class="kt">LFThunk</span><span class="w">             </span><span class="c1">-- Thunk (zero arity)</span>
<span class="w">        </span><span class="o">!</span><span class="kt">TopLevelFlag</span>
<span class="w">        </span><span class="o">!</span><span class="kt">Bool</span><span class="w">           </span><span class="c1">-- True &lt;=&gt; no free vars</span>
<span class="w">        </span><span class="o">!</span><span class="kt">Bool</span><span class="w">           </span><span class="c1">-- True &lt;=&gt; updatable (i.e., *not* single-entry)</span>
<span class="w">        </span><span class="o">!</span><span class="kt">StandardFormInfo</span>
<span class="w">        </span><span class="o">!</span><span class="kt">Bool</span><span class="w">           </span><span class="c1">-- True &lt;=&gt; *might* be a function type</span>
<span class="o">...</span>
</pre></div>
</div>
</li>
</ol>
<p>The constructor <code class="docutils literal notranslate"><span class="pre">LFThunk</span></code> has five fields, three of which are <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. This
means, in the abstract, that we only need three bits to store the information
that these <code class="docutils literal notranslate"><span class="pre">Bool</span></code>’s represent. Yet in this constructor each <code class="docutils literal notranslate"><span class="pre">Bool</span></code> will be
padded by GHC to a machine word. Therefore, <em>each</em> <code class="docutils literal notranslate"><span class="pre">Bool</span></code> is represented with
64-bits on a typical x86_64 machine (32-bits for x86 and for other backends such
as the JavaScript backend). Thus, one <code class="docutils literal notranslate"><span class="pre">LFThunk</span></code> heap object will require 320
bits (192 bits for the <code class="docutils literal notranslate"><span class="pre">Bool</span></code>’s, 128 for the other two fields), of which 188
bits will always be zero because they are wasted space. Similarly,
<code class="docutils literal notranslate"><span class="pre">TopLevelFlag</span></code> is isomorphic to a <code class="docutils literal notranslate"><span class="pre">Bool</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">TopLevelFlag</span>
<span class="ow">=</span><span class="w"> </span><span class="kt">TopLevel</span>
<span class="o">|</span><span class="w"> </span><span class="kt">NotTopLevel</span>
<span class="kr">deriving</span><span class="w"> </span><span class="kt">Data</span>
</pre></div>
</div>
<p>So a more efficient representation <em>only requires</em> 4 bits and then a pointer to
<code class="docutils literal notranslate"><span class="pre">StandardFormInfo</span></code> for a total of 66 bits. However, this must still be aligned
and padded; yielding a total of 72 bits, which is a 77% improvement in memory
efficiency.</p>
<p>Non-pessimization should be the bulk of your optimization efforts. Not only is
it portable to other machines, but it is also simpler and more future proof than
actual optimization.</p>
</section>
<section id="fake-optimization">
<span id="id5"></span><h2><span class="section-number">1.3.3. </span>Fake Optimization<a class="headerlink" href="#fake-optimization" title="Link to this heading">¶</a></h2>
<p>Fake optimization is a philosophy of performance that will not lead to better
code or better performance. Rather, fake optimization is advice that one finds
around the internet. These are sayings such as “You should never use &lt;Foo&gt;!”, or
“Google doesn’t use &lt;Bar&gt; therefore you shouldn’t either!”, or “you should
always use arrays and never use linked-lists”. Notice that each of these
statements are categorical; they claim something is <em>always</em> fast or slow or one
should <em>never</em> or <em>always</em> use something or other.</p>
<p>These statements are called fake optimizations because they are advice or
aphorisms that are divorced from the context of your code, the problem your code
wants to solve and the work it must perform to do so. An algorithm or data
structure is not <em>universally</em> bad or good, or fast or slow. It could be the
case that for a particular workload, and for a particular memory access pattern,
a linked-list is the right choice. The key point is that whether an algorithm or
data structure is fast or not depends on numerous factors. Factors such as what
your program has to do, what the properties of the data your program is
processing are, and what the memory access patterns are. Another example of a
fake optimization statement is “quick-sort is always faster than
insertion sort”. This is a fake optimization because while quick-sort has better
time complexity than insertion sort, for small lists (usually less than 30
elements) insertion sort will be more performant <a class="footnote-reference brackets" href="#id9" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
<p>The key idea is that the performance of your code is very sensitive to the
specific problem and data the code operates on. So beware of fake optimization
statements for they will waste your time and iteration cycles.</p>
</section>
</section>
<section id="references-and-footnotes">
<h1><span class="section-number">1.4. </span>References and Footnotes<a class="headerlink" href="#references-and-footnotes" title="Link to this heading">¶</a></h1>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="https://youtu.be/pgoetgxecw8?si=0csotFBkya5gGDvJ">this</a> series by
Casey Muratori. We thank him for his labor.</p>
</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">2</a><span class="fn-bracket">]</span></span>
<p>I hear you say “but this is Haskell!” why wouldn’t I use algebraic data
types to model my domain and increase the correctness and maintainability
of my code! And you are correct to feel this way, but in this domain, we
are looking for performance at the expense of these other properties and
in this pursuit you should be prepared to kill your darlings. This does
not mean you must start rewriting your entire code base. Far from it, in
practice you should only need to non-pessimize certain high-performance
subsystems in your code base. So it is key that one practices writing
non-pessimized Haskell such that when the need arises you understand how
to speed up some subsystem by employing non-pessimizing techniques.</p>
</aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">3</a><span class="fn-bracket">]</span></span>
<p>See this <a class="reference external" href="https://youtu.be/FJJTYQYB1JQ?si=L2pDU5AqFNjFC1hK">keynote</a>
by Andrei Alexandrescu. Another example is <a class="reference external" href="https://en.wikipedia.org/wiki/Timsort">timsort</a> in Python. Python <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-July/026837.html">adopted</a>
timsort because most real-world data is nearly sorted, thus the
worst-case <em>in practice</em> is vanishingly rare.</p>
</aside>
</aside>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="what_makes_fast_hs.html"
       title="previous chapter">← <span class="section-number">1.2. </span>The Programs of Consistent Lethargy</a>
  </li>
  <li class="next">
    <a href="golden_rules.html"
       title="next chapter"><span class="section-number">1.5. </span><span class="lightgrey">The Golden Rules of Performance-Oriented Haskell</span> →</a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; Copyright 2022-2024, Jeffrey Young (doyougnu).
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.2.6 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>