<!DOCTYPE html>
<html  lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

      <title>Glossary</title>
    
          <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../_static/theme.css " type="text/css" />
          <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
          <link rel="stylesheet" href="../_static/css/s4defs-roles.css" type="text/css" />
          <link rel="stylesheet" href="../_static/css/iframe.css" type="text/css" />
          <link rel="stylesheet" href="../_static/css/admonitions.css" type="text/css" />
          <link rel="stylesheet" href="../_static/css/s4defs-roles.css" type="text/css" />
          <link rel="stylesheet" href="../_static/css/iframe.css" type="text/css" />
          <link rel="stylesheet" href="../_static/css/admonitions.css" type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../_static/theme-vendors.js"></script> -->
      <script src="../_static/theme.js" defer></script>
    
  <link rel="index" title="Index" href="../genindex.html" />
  <link rel="search" title="Search" href="../search.html" />
  <link rel="prev" title="4.3. Klister: A First Pass Performance Engineering" href="Case_Studies/klister.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../contents.html" class="home-link">
    
      <span class="site-name">Haskell Optimization Handbook</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">

  
    <div class="nav-item">
      <a href="../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../contents.html#indices-and-tables"
         class="nav-link  router-link-active">
         indices and tables
      </a>
    </div>
  



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            

  
    <div class="nav-item">
      <a href="../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../contents.html#indices-and-tables"
         class="nav-link  router-link-active">
         indices and tables
      </a>
    </div>
  



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Quick search</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Search" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../contents.html#haskell-optimization-handbook">Table of Contents</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="Preliminaries/index.html" class="reference internal ">Preliminaries</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Measurement_Observation/index.html" class="reference internal ">Measurement, Profiling, and Observation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Optimizations/index.html" class="reference internal ">Optimizations</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Case_Studies/index.html" class="reference internal ">Case Studies</a>
            

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../contents.html#indices-and-tables">indices and tables</a></span>
      </p>
      <ul class="current">
        
          <li class="toctree-l1 current">
            
              <a href="#" class="reference internal current">Glossary</a>
            

            
              <ul>
                
                  <li class="toctree-l2"><a href="#glossary" class="reference internal">Glossary</a></li>
                
              </ul>
            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../contents.html">Docs</a> &raquo;</li>
    
    <li>Glossary</li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="Case_Studies/klister.html"
       title="previous chapter">← <span class="section-number">4.3. </span><span class="incremental">Klister: A First Pass Performance Engineering</span></a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="glossary">
<span id="id1"></span><h1>Glossary<a class="headerlink" href="#glossary" title="Permalink to this heading">¶</a></h1>
<dl class="glossary">
<dt id="term-Arity">Arity<a class="headerlink" href="#term-Arity" title="Permalink to this term">¶</a></dt><dd><p>The arity of a function is the number of arguments the function must take
to conclude to a result.</p>
</dd>
<dt id="term-Boxed">Boxed<a class="headerlink" href="#term-Boxed" title="Permalink to this term">¶</a></dt><dd><p>A Boxed value is a value that is represented by a pointer to the heap.</p>
</dd>
<dt id="term-Cardinality-Analysis">Cardinality Analysis<a class="headerlink" href="#term-Cardinality-Analysis" title="Permalink to this term">¶</a></dt><dd><p>A static analysis that GHC performs to determine:
#. How many times a lambda-expression is called.
#. Which components of a data structure are never evaluated.
#. How many times a particular thunk is evaluated.</p>
<p>See <span id="id2">Graf [<a class="reference internal" href="../contents.html#id14" title="Sebastian Graf. Call arity vs. demand analysis. August 2017.">7</a>]</span> and <span id="id3">Sergey <em>et al.</em> [<a class="reference internal" href="../contents.html#id16" title="Ilya Sergey, Dimitrios Vytiniotis, and Simon Peyton Jones. Modular, higher-order cardinality analysis in theory and practice. SIGPLAN Not., 49(1):335–347, jan 2014. URL: https://doi.org/10.1145/2578855.2535861, doi:10.1145/2578855.2535861.">8</a>]</span> for
more.</p>
</dd>
<dt id="term-Closure">Closure<a class="headerlink" href="#term-Closure" title="Permalink to this term">¶</a></dt><dd><p>A closure is value that pairs a function with an environment, where the
environment maps every free variable in the function with a value or
reference to which the free variable was bound when the closure was
created. Closure’s are the canonical way to realize lexical scoping in
languages with first-class functions, such a Haskell. See <a class="reference external" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">the wikipedia</a> entry for
more.</p>
</dd>
<dt id="term-Closure-Conversion">Closure Conversion<a class="headerlink" href="#term-Closure-Conversion" title="Permalink to this term">¶</a></dt><dd><p>Closure conversion is the default way GHC treats free variables in a
function body. Closure Conversion creates a top level record for the
original function, called the function environment, whose fields are the
free variables of the function. The environment is passed to the function
as an implicit parameter and the free variable call sites are rewritten as
field accesses. Then the function and the record are grouped in a tuple,
i.e., a closure (pair of environment and function) is created causing some
extra heap allocation. Finally the call sites of the original function are
rewritten to pass the environment with the original function. Consider
this example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span><span class="w"></span>
<span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">acc</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
<span class="kr">in</span><span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>In this example <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are free variables in the function <code class="docutils literal notranslate"><span class="pre">f</span></code> .
Closure conversion will capture them and transform this function to:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span><span class="w"></span>
<span class="c1">-- the function environment</span><span class="w"></span>
<span class="kr">data</span><span class="w"> </span><span class="kt">EnvF</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">EnvF</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="c1">-- the new function</span><span class="w"></span>
<span class="nf">f_cc</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">acc</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">env</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="n">env</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>

<span class="c1">-- the closure that replaces the original function in the same scope</span><span class="w"></span>
<span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">f_cc</span><span class="p">,</span><span class="w"> </span><span class="kt">EnvF</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="kr">in</span><span class="w"> </span><span class="p">(</span><span class="n">fst</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">snd</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
</pre></div>
</div>
<p>Notice closure conversion has <em>added</em> an extra <code class="docutils literal notranslate"><span class="pre">let</span></code> expression for the
closure and the reference to <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> have been replaced with
accesses to <code class="docutils literal notranslate"><span class="pre">env</span></code> . The let expression can be a source of extra heap
allocations and is one of the costs of closure conversion. However, the
benefits are uniformity; every function can be treated as a closure.
Closure conversion is often contrasted with Lambda Lifting which is
another strategy to handle free variables that does not incur extra heap
allocation. See <span id="id4">Johnsson [<a class="reference internal" href="../contents.html#id12" title="Thomas Johnsson. Lambda lifting: transforming programs to recursive equations. In Jean-Pierre Jouannaud, editor, Functional Programming Languages and Computer Architecture, 190–203. Berlin, Heidelberg, 1985. Springer Berlin Heidelberg.">3</a>]</span> and
<span id="id5">Graf and Jones [<a class="reference internal" href="../contents.html#id13" title="Sebastian Graf and Simon Peyton Jones. Selective lambda lifting. 2019. URL: https://arxiv.org/abs/1910.11717, doi:10.48550/ARXIV.1910.11717.">4</a>]</span> for more.</p>
</dd>
<dt id="term-CAF">CAF<a class="headerlink" href="#term-CAF" title="Permalink to this term">¶</a></dt><dd><p>A CAF, or Constant Applicative Form, is a Haskell value which contains no
free variables and is not a function. Consider these examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- these are CAFs</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">12</span><span class="w"></span>

<span class="nf">bar</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">])</span><span class="w"></span>
<span class="nf">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])</span><span class="w"></span>

<span class="c1">-- not a lambda, curried functions that can be reduced when given an</span><span class="w"></span>
<span class="c1">-- input are CAFs</span><span class="w"></span>
<span class="nf">baz</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">baz</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>

<span class="c1">-- not CAFs</span><span class="w"></span>
<span class="nf">qux</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">qux</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w">     </span><span class="c1">-- equivalent to baz but is a lambda so not a CAF</span><span class="w"></span>

<span class="nf">quux</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">quux</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w">      </span><span class="c1">-- x is free thus not a CAF</span><span class="w"></span>
</pre></div>
</div>
<p>These values are <em>constant</em> because they don’t bind any variables or have
any free variables. Because they are constant they are floated (see
<a class="reference internal" href="#term-Let-Floating"><span class="xref std std-term">Let Floating</span></a>) to the top of the program, and statically allocated
during compile time. Since they are statically allocated at compile time
CAFs are pinned memory and special treatment in the runtime system. Thus,
heavily allocating CAFs can increase memory residency. See
<span id="id6">Jones <em>et al.</em> [<a class="reference internal" href="../contents.html#id3" title="Peyton Jones, Simon L, and Simon Peyton Jones. Implementing lazy functional languages on stock hardware: the spineless tagless g-machine. Journal of Functional Programming, 2:127-202, July 1992. URL: https://www.microsoft.com/en-us/research/publication/implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-g-machine/.">9</a>]</span> Section 10.8 for more details.</p>
</dd>
<dt id="term-DWARF">DWARF<a class="headerlink" href="#term-DWARF" title="Permalink to this term">¶</a></dt><dd><p>DWARF symbols are a widely used and standardized data format used to
provide source level debugging. For more, see <a class="reference external" href="https://dwarfstd.org/">the official webpage</a>.</p>
</dd>
<dt id="term-Entry-Code">Entry Code<a class="headerlink" href="#term-Entry-Code" title="Permalink to this term">¶</a></dt><dd><p>The entry code for a closure on the heap is the code that will evaluate
that closure. There are some nuances and exceptions: For functions the
entry code applies the function to its arguments, which the entry code
assumes are all present; that is, the entry code assumes all arguments are
either loaded into registers or are already on the stack. Should the
function be applied to too few arguments or should the function be an
<a class="reference internal" href="#term-Unknown-function"><span class="xref std std-term">Unknown function</span></a> then a generic apply is used. For a <a class="reference internal" href="#term-PAP"><span class="xref std std-term">PAP</span></a>,
there is no entry code. PAPs can only be applied to more arguments using
the generic apply functions. Lastly, <a class="reference internal" href="#term-Unlifted"><span class="xref std std-term">Unlifted</span></a> Objects cannot be
evaluated and thus have no entry code.</p>
</dd>
<dt id="term-Full-Laziness-transformation">Full Laziness transformation<a class="headerlink" href="#term-Full-Laziness-transformation" title="Permalink to this term">¶</a></dt><dd><p>A form of <a class="reference internal" href="#term-Let-Floating"><span class="xref std std-term">Let Floating</span></a> which moves let bindings out of lambda
abstractions to avoid unnecessary allocation and computation. See
<span id="id7">Peyton Jones and Santos [<a class="reference internal" href="../contents.html#id5" title="Simon Peyton Jones and Andre Santos. A transformation-based optimiser for haskell. Science of Computer Programming, October 1997. URL: https://www.microsoft.com/en-us/research/publication/a-transformation-based-optimiser-for-haskell/.">1</a>]</span> Section 7.2.</p>
</dd>
<dt id="term-Fusion">Fusion<a class="headerlink" href="#term-Fusion" title="Permalink to this term">¶</a></dt><dd><p>See <a class="reference internal" href="Preliminaries/what_makes_fast_hs.html#canonical-fusion"><span class="std std-ref">What is Fusion</span></a>.</p>
</dd>
<dt id="term-HNF">HNF<a class="headerlink" href="#term-HNF" title="Permalink to this term">¶</a></dt><dd><p>An expression that is in <em>head normal form</em> is a value which contains at
least one <a class="reference internal" href="#term-Thunk"><span class="xref std std-term">thunk</span></a>. If the value does not contain any thunks, then it
is said to be in normal form (<a class="reference internal" href="#term-NF"><span class="xref std std-term">NF</span></a>). See
<span id="id8">Jones <em>et al.</em> [<a class="reference internal" href="../contents.html#id3" title="Peyton Jones, Simon L, and Simon Peyton Jones. Implementing lazy functional languages on stock hardware: the spineless tagless g-machine. Journal of Functional Programming, 2:127-202, July 1992. URL: https://www.microsoft.com/en-us/research/publication/implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-g-machine/.">9</a>]</span> Section 3.1 for more.</p>
</dd>
<dt id="term-Info-Table">Info Table<a class="headerlink" href="#term-Info-Table" title="Permalink to this term">¶</a></dt><dd><p>Every heap allocated object in the runtime system keeps an information
table that stores data such as: the object type (function, data
constructor, thunk etc.) before the payload of the object. This is called
the info table. See <span id="id9">Marlow <em>et al.</em> [<a class="reference internal" href="../contents.html#id11" title="Simon Marlow, Alexey Rodriguez Yakushev, and Simon Peyton Jones. Faster laziness using dynamic pointer tagging. SIGPLAN Not., 42(9):277–288, oct 2007. URL: https://doi.org/10.1145/1291220.1291194, doi:10.1145/1291220.1291194.">2</a>]</span> and the
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/heap-objects#info-tables">wiki</a> for more
details.</p>
</dd>
<dt id="term-Info-Table-Address">Info Table Address<a class="headerlink" href="#term-Info-Table-Address" title="Permalink to this term">¶</a></dt><dd><p>The memory address for heap object descriptors <a class="reference internal" href="#term-Info-Table"><span class="xref std std-term">info table</span></a>.</p>
</dd>
<dt id="term-Join-Point">Join Point<a class="headerlink" href="#term-Join-Point" title="Permalink to this term">¶</a></dt><dd><p>A join point is a place where different execution paths come together or
<em>join</em>. Consider this example slightly modified from
<span id="id10">Maurer <em>et al.</em> [<a class="reference internal" href="../contents.html#id2" title="Luke Maurer, Paul Downen, Zena M. Ariola, and Simon Peyton Jones. Compiling without continuations. In Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2017, 482–494. New York, NY, USA, 2017. Association for Computing Machinery. URL: https://doi.org/10.1145/3062341.3062380, doi:10.1145/3062341.3062380.">10</a>]</span>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">join1</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">some_large_expression</span><span class="w"></span>
<span class="w">    </span><span class="n">join2</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">some_other_large_expr</span><span class="w"></span>
<span class="kr">in</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="p">(</span><span class="kr">if</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">join1</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">join2</span><span class="w"> </span><span class="nb">()</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="kr">else</span><span class="w"> </span><span class="p">(</span><span class="kr">if</span><span class="w"> </span><span class="n">e3</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">join1</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">join2</span><span class="w"> </span><span class="nb">()</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">join1</span></code> and <code class="docutils literal notranslate"><span class="pre">join2</span></code> are join points because the
branches described by each if-expression conclude by calling them. Thus,
the control flow described by the if-expressions joins at specifically
<code class="docutils literal notranslate"><span class="pre">join1</span></code> and <code class="docutils literal notranslate"><span class="pre">join2</span></code>. Join points are an important optimization
technique that GHC performs automatically to remove redundant allocations.
Had we not wrapped <code class="docutils literal notranslate"><span class="pre">some_large_expression</span></code> and <code class="docutils literal notranslate"><span class="pre">some_other_large_expr</span></code>
in a <code class="docutils literal notranslate"><span class="pre">let</span></code>, then these expressions would be duplicated <em>and</em> would be
captured in an additionally allocated closure unnecessarily. Join points
avoid these problems and are particularly relevant for Stream
<a class="reference internal" href="#term-Fusion"><span class="xref std std-term">Fusion</span></a> performance.</p>
</dd>
<dt id="term-Known-Function">Known Function<a class="headerlink" href="#term-Known-Function" title="Permalink to this term">¶</a></dt><dd><p>A known function is a function in the STG machine of which GHC statically
knows the <a class="reference internal" href="#term-Entry-Code"><span class="xref std std-term">Entry Code</span></a> pointer and the <a class="reference internal" href="#term-Arity"><span class="xref std std-term">Arity</span></a> of. This means
that the function binding site is statically visible, that is, the
function is <a class="reference internal" href="#term-Top-Level"><span class="xref std std-term">Top-Level</span></a>, or the function is bound by an enclosing
<code class="docutils literal notranslate"><span class="pre">let</span></code>. With this information the STG machine can use a faster function
application procedure because the function pointer does not need to be
scrutinized. See also <a class="reference internal" href="#term-Unknown-function"><span class="xref std std-term">Unknown Function</span></a>.</p>
</dd>
<dt id="term-Levity-Polymorphism">Levity Polymorphism<a class="headerlink" href="#term-Levity-Polymorphism" title="Permalink to this term">¶</a></dt><dd><p>A kind of polymorphism that abstracts over calling conventions which
allows levity polymorphic functions to be abstracted over memory layout.
See <span id="id11">Eisenberg and Peyton Jones [<a class="reference internal" href="../contents.html#id9" title="Richard A. Eisenberg and Simon Peyton Jones. Levity polymorphism. SIGPLAN Not., 52(6):525–539, jun 2017. URL: https://doi.org/10.1145/3140587.3062357, doi:10.1145/3140587.3062357.">11</a>]</span> for a more precise technical definition
and discussion.</p>
</dd>
<dt id="term-Let-Floating">Let Floating<a class="headerlink" href="#term-Let-Floating" title="Permalink to this term">¶</a></dt><dd><p>A group of optimizing transformation’s that move <code class="docutils literal notranslate"><span class="pre">let</span></code> bindings to
reduce heap allocations. See <span id="id12">Partain <em>et al.</em> [<a class="reference internal" href="../contents.html#id8" title="WD Partain, A Santos, and Simon Peyton Jones. Let-floating: moving bindings to give faster programs. May 1996. ACM SIGPLAN International Conference on Functional Programming (ICFP'96). URL: https://www.microsoft.com/en-us/research/publication/let-floating-moving-bindings-to-give-faster-programs/.">12</a>]</span> and
<span id="id13">Peyton Jones and Santos [<a class="reference internal" href="../contents.html#id5" title="Simon Peyton Jones and Andre Santos. A transformation-based optimiser for haskell. Science of Computer Programming, October 1997. URL: https://www.microsoft.com/en-us/research/publication/a-transformation-based-optimiser-for-haskell/.">1</a>]</span> Section 7 for more details.</p>
</dd>
<dt id="term-Lifted">Lifted<a class="headerlink" href="#term-Lifted" title="Permalink to this term">¶</a></dt><dd><p>A Lifted type is a type that contains the value <span class="math notranslate nohighlight">\(\bot\)</span>;
which represents non-terminating computation. For example, the <code class="docutils literal notranslate"><span class="pre">Bool</span></code>
type is a set with three values: <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>, and <span class="math notranslate nohighlight">\(\bot\)</span>.
Therefore <code class="docutils literal notranslate"><span class="pre">Bool</span></code> is a Lifted type.</p>
</dd>
<dt id="term-Loop-Fusion">Loop Fusion<a class="headerlink" href="#term-Loop-Fusion" title="Permalink to this term">¶</a></dt><dd><p>Loop fusion is a classic optimization technique that reduces the number of
loops in a program, thereby reducing the number of memory accesses and the
number of looping constructs. In Haskell, loop fusion transforms many
traversals over the same data structure to a single traversal. A classic
example of this is map fusion.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- two traversals, one for f, one for g on the result of f</span><span class="w"></span>
<span class="nf">map</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span><span class="w"></span>

<span class="c1">-- after map fusion:</span><span class="w"></span>
<span class="c1">-- only one traversal</span><span class="w"></span>
<span class="nf">map</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>This can also appear in list comprehensions, for example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span><span class="w"></span>
<span class="c1">-- three traversals: two to project elements, 1 to fold</span><span class="w"></span>
<span class="kr">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="kr">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="n">foo</span><span class="w">   </span><span class="p">[</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="p">]</span><span class="w"></span>

<span class="c1">-- after loop fusion on the list comprehensions</span><span class="w"></span>
<span class="c1">-- 2 traversals: one for the arguments, one to fold</span><span class="w"></span>
<span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="w"> </span><span class="n">js</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">unzip</span><span class="w"> </span><span class="n">args</span><span class="w"></span>
<span class="kr">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">is</span><span class="w"></span>
<span class="kr">let</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">js</span><span class="w"></span>
</pre></div>
</div>
</dd>
<dt id="term-Multi-Shot-Lambda">Multi-Shot Lambda<a class="headerlink" href="#term-Multi-Shot-Lambda" title="Permalink to this term">¶</a></dt><dd><p>A multi-shot lambda is a lambda that is called <em>more</em> than once. In
contrast to a <a class="reference internal" href="#term-One-Shot-Lambda"><span class="xref std std-term">one-shot lambda</span></a>, a multi-shot lambda has a high risk
of destroying <a class="reference internal" href="#term-Sharing"><span class="xref std std-term">sharing</span></a> if subject to certain optimizations, such as
Inlining. GHC determines whether a lambda is one-shot or multi-shot during
<a class="reference internal" href="#term-Cardinality-Analysis"><span class="xref std std-term">Cardinality Analysis</span></a>. See <span id="id14">Sergey <em>et al.</em> [<a class="reference internal" href="../contents.html#id16" title="Ilya Sergey, Dimitrios Vytiniotis, and Simon Peyton Jones. Modular, higher-order cardinality analysis in theory and practice. SIGPLAN Not., 49(1):335–347, jan 2014. URL: https://doi.org/10.1145/2578855.2535861, doi:10.1145/2578855.2535861.">8</a>]</span> and
<span id="id15">Graf [<a class="reference internal" href="../contents.html#id14" title="Sebastian Graf. Call arity vs. demand analysis. August 2017.">7</a>]</span> for more.</p>
</dd>
<dt id="term-NF">NF<a class="headerlink" href="#term-NF" title="Permalink to this term">¶</a></dt><dd><p>An expression that is in <em>normal form</em> is a fully evaluated expression and
is a value which contains no thunks. This is in contrast to weak head
normal form (<a class="reference internal" href="#term-WHNF"><span class="xref std std-term">WHNF</span></a>) and head normal form (<a class="reference internal" href="#term-HNF"><span class="xref std std-term">HNF</span></a>), both of
which may contain thunks. See <span id="id16">Jones <em>et al.</em> [<a class="reference internal" href="../contents.html#id3" title="Peyton Jones, Simon L, and Simon Peyton Jones. Implementing lazy functional languages on stock hardware: the spineless tagless g-machine. Journal of Functional Programming, 2:127-202, July 1992. URL: https://www.microsoft.com/en-us/research/publication/implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-g-machine/.">9</a>]</span> Section 3.1
for more.</p>
</dd>
<dt id="term-One-Shot-Lambda">One-Shot Lambda<a class="headerlink" href="#term-One-Shot-Lambda" title="Permalink to this term">¶</a></dt><dd><p>A one-shot lambda is a lambda that is called <em>exactly</em> once. These
lambda’s are common in functional programming and can be subject to more
aggressive optimizations due to their one-shot nature. For example, there
is no risk of losing <a class="reference internal" href="#term-Sharing"><span class="xref std std-term">sharing</span></a> in a one-shot lambda as a result of
inlining free variables or floating let expressions <em>into</em> the lambda;
something that GHC usually avoids. See <span id="id17">Sergey <em>et al.</em> [<a class="reference internal" href="../contents.html#id16" title="Ilya Sergey, Dimitrios Vytiniotis, and Simon Peyton Jones. Modular, higher-order cardinality analysis in theory and practice. SIGPLAN Not., 49(1):335–347, jan 2014. URL: https://doi.org/10.1145/2578855.2535861, doi:10.1145/2578855.2535861.">8</a>]</span> and
<span id="id18">Graf [<a class="reference internal" href="../contents.html#id14" title="Sebastian Graf. Call arity vs. demand analysis. August 2017.">7</a>]</span> for more background. See the magic
<a class="reference external" href="https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-Exts.html#v:oneShot">oneShot</a>
function in <a class="reference external" href="https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-Exts.html">GHC.Exts</a>
for an unsafe way to instruct GHC that you have a one-shot lambda.</p>
</dd>
<dt id="term-PAP">PAP<a class="headerlink" href="#term-PAP" title="Permalink to this term">¶</a></dt><dd><p>A PAP is a partial application. PAPs are heap objects and thus a type of
closure that represents a function applied to <em>too few</em> arguments. PAPs
should never be entered, and are only applied using the generic apply
functions in the STG machine. See the file <code class="docutils literal notranslate"><span class="pre">rts/Apply.cmm</span></code> in GHC or the
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/heap-objects">heap object</a> wiki page for
more.</p>
</dd>
<dt id="term-Pinned">Pinned<a class="headerlink" href="#term-Pinned" title="Permalink to this term">¶</a></dt><dd><p>Pinned memory is memory that is guaranteed to not be moved by GHC’s garbage
collector. This is most often useful for interfacing with foreign code.
Note that pinned memory may lead to memory fragmentation and increased slop
because it never moves. See <a class="reference external" href="https://well-typed.com/blog/2020/08/memory-fragmentation/">Well Typed’s</a> post and the
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/storage/gc/pinned">wiki</a>
for more.</p>
</dd>
<dt id="term-Sharing">Sharing<a class="headerlink" href="#term-Sharing" title="Permalink to this term">¶</a></dt><dd><p>Consider the following program:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">foo</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">]</span><span class="w"></span>
<span class="w">            </span><span class="kr">in</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="p">(</span><span class="n">fmap</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">last</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
</pre></div>
</div>
<p>We say that <code class="docutils literal notranslate"><span class="pre">x</span></code> is <em>shared</em> in this program because each of the three
references of <code class="docutils literal notranslate"><span class="pre">x</span></code> refer to the <code class="docutils literal notranslate"><span class="pre">x</span></code> defined in the <code class="docutils literal notranslate"><span class="pre">let</span></code>. If <code class="docutils literal notranslate"><span class="pre">x</span></code> is
not shared that the list <code class="docutils literal notranslate"><span class="pre">[1..n]</span></code> would be allocated <em>for each</em>
reference of <code class="docutils literal notranslate"><span class="pre">x</span></code>. Thus, sharing is fundamental to performance oriented
Haskell because it reduces allocations, leverages call-by-need, and saves
work.</p>
</dd>
<dt id="term-Thunk">Thunk<a class="headerlink" href="#term-Thunk" title="Permalink to this term">¶</a></dt><dd><p>A thunk is a special kind of <a class="reference internal" href="#term-Closure"><span class="xref std std-term">Closure</span></a> that represents a suspended
computation. Thunks reside on the heap and are the key feature that
provides Haskell’s laziness. See <span id="id19">Peyton Jones and Salkild [<a class="reference internal" href="../contents.html#id7" title="Simon L. Peyton Jones and Jon Salkild. The spineless tagless g-machine. In Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture, FPCA '89, 184–201. New York, NY, USA, 1989. Association for Computing Machinery. URL: https://doi.org/10.1145/99370.99385, doi:10.1145/99370.99385.">13</a>]</span>
Section 3.1.2 for more details.</p>
</dd>
<dt id="term-Top-Level">Top-Level<a class="headerlink" href="#term-Top-Level" title="Permalink to this term">¶</a></dt><dd><p>The most outer-most or global scope of the program.</p>
</dd>
<dt id="term-Unboxed">Unboxed<a class="headerlink" href="#term-Unboxed" title="Permalink to this term">¶</a></dt><dd><p>An UnBoxed value is a value that is represented by the value itself.
UnBoxed values therefore cannot be lazy, like boxed values.</p>
</dd>
<dt id="term-Unlifted">Unlifted<a class="headerlink" href="#term-Unlifted" title="Permalink to this term">¶</a></dt><dd><p>An Unlifted type is a type where <span class="math notranslate nohighlight">\(\bot\)</span> <em>is not</em> an element of that
type. See <a class="reference internal" href="#term-Levity-Polymorphism"><span class="xref std std-term">Levity Polymorphism</span></a> and <a class="reference internal" href="#term-Lifted"><span class="xref std std-term">Lifted</span></a> types for more.</p>
</dd>
<dt id="term-Unknown-function">Unknown function<a class="headerlink" href="#term-Unknown-function" title="Permalink to this term">¶</a></dt><dd><p>An unknown function is a function in the STG machine whose <a class="reference internal" href="#term-Entry-Code"><span class="xref std std-term">Entry
Code</span></a> pointer and <a class="reference internal" href="#term-Arity"><span class="xref std std-term">Arity</span></a> are not statically known by GHC. Unknown
functions require GHC to generate code that first scrutinizes the function
pointer to determine its arity and then dispatch to the normal function
call handling procedures. This in known has a generic apply in the STG
machine and is slower (due to needing to scrutinize the function) than a
<a class="reference internal" href="#term-Known-Function"><span class="xref std std-term">Known function</span></a>. See <span id="id20">Marlow and Jones [<a class="reference internal" href="../contents.html#id15" title="Simon Marlow and Simon Peyton Jones. Making a fast curry: push/enter vs. eval/apply for higher-order languages. In Proceedings of the Ninth ACM SIGPLAN International Conference on Functional Programming, ICFP '04, 4–15. New York, NY, USA, 2004. Association for Computing Machinery. URL: https://doi.org/10.1145/1016850.1016856, doi:10.1145/1016850.1016856.">14</a>]</span> for more details on STG
calling conventions.</p>
</dd>
<dt id="term-WHNF">WHNF<a class="headerlink" href="#term-WHNF" title="Permalink to this term">¶</a></dt><dd><p>An expression is in <em>weak head normal form</em> if it has been evaluated to
its’ outermost data constructor or lambda abstraction (i.e., <em>the head</em>).
See <a class="reference external" href="https://stackoverflow.com/questions/6872898/what-is-weak-head-normal-form/6889335#6889335">this</a>
post, <a class="reference external" href="https://wiki.haskell.org/Weak_head_normal_form">the wiki</a> , and
<a class="reference external" href="https://en.wikipedia.org/wiki/Lambda_calculus_definition#Weak_head_normal_form">wikipedia</a>
for more.</p>
</dd>
</dl>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="Case_Studies/klister.html"
       title="previous chapter">← <span class="section-number">4.3. </span><span class="incremental">Klister: A First Pass Performance Engineering</span></a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; Copyright 2022-2023, Jeffrey Young (doyougnu).
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.1.1 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>