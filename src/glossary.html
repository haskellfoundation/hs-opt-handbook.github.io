<!DOCTYPE html>
<html  lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="viewport" content="width=device-width, initial-scale=1" />

      <title>Glossary</title>
    
          <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../_static/theme.css " type="text/css" />
          <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
          <link rel="stylesheet" href="../_static/css/s4defs-roles.css" type="text/css" />
          <link rel="stylesheet" href="../_static/css/iframe.css" type="text/css" />
          <link rel="stylesheet" href="../_static/css/admonitions.css" type="text/css" />
          <link rel="stylesheet" href="../_static/css/s4defs-roles.css" type="text/css" />
          <link rel="stylesheet" href="../_static/css/iframe.css" type="text/css" />
          <link rel="stylesheet" href="../_static/css/admonitions.css" type="text/css" />
      
      <!-- sphinx script_files -->
        <script src="../_static/documentation_options.js?v=d45e8c67"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../_static/copybutton.js?v=f281be69"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../_static/theme-vendors.js"></script> -->
      <script src="../_static/theme.js" defer></script>
    
  <link rel="index" title="Index" href="../genindex.html" />
  <link rel="search" title="Search" href="../search.html" />
  <link rel="prev" title="4.3. Klister: A First Pass Performance Engineering" href="Case_Studies/klister.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../contents.html" class="home-link">
    
      <span class="site-name">Haskell Optimization Handbook</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">

  
    <div class="nav-item">
      <a href="../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../contents.html#indices-and-tables"
         class="nav-link  router-link-active">
         indices and tables
      </a>
    </div>
  



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            

  
    <div class="nav-item">
      <a href="../contents.html#haskell-optimization-handbook"
         class="nav-link ">
         Table of Contents
      </a>
    </div>
  
    <div class="nav-item">
      <a href="../contents.html#indices-and-tables"
         class="nav-link  router-link-active">
         indices and tables
      </a>
    </div>
  



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Quick search</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Search" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../contents.html#haskell-optimization-handbook">Table of Contents</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="Preliminaries/index.html" class="reference internal ">Preliminaries</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Measurement_Observation/index.html" class="reference internal ">Measurement, Profiling, and Observation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Optimizations/index.html" class="reference internal ">Optimizations</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Case_Studies/index.html" class="reference internal ">Case Studies</a>
            

            
          </li>

        
      </ul>
    </div>
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../contents.html#indices-and-tables">indices and tables</a></span>
      </p>
      <ul class="current">
        
          <li class="toctree-l1 current">
            
              <a href="#" class="reference internal current">Glossary</a>
            

            
              <ul>
                
                  <li class="toctree-l2"><a href="#glossary" class="reference internal">Glossary</a></li>
                
              </ul>
            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../contents.html">Docs</a> &raquo;</li>
    
    <li>Glossary</li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="Case_Studies/klister.html"
       title="previous chapter">← <span class="section-number">4.3. </span><span class="incremental">Klister: A First Pass Performance Engineering</span></a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="glossary">
<span id="id1"></span><h1>Glossary<a class="headerlink" href="#glossary" title="Link to this heading">¶</a></h1>
<dl class="glossary">
<dt id="term-Arity">Arity<a class="headerlink" href="#term-Arity" title="Link to this term">¶</a></dt><dd><p>The arity of a function is the number of arguments the function must take
to conclude to a result.</p>
</dd>
<dt id="term-Algebraic-Data-Type">Algebraic Data Type<a class="headerlink" href="#term-Algebraic-Data-Type" title="Link to this term">¶</a></dt><dd><p>First implemented in the Hope programming language
<span id="id2">Hudak <em>et al.</em> [<a class="reference internal" href="../contents.html#id19" title="Paul Hudak, John Hughes, Simon Peyton Jones, and Philip Wadler. A history of haskell: being lazy with class. In Proceedings of the Third ACM SIGPLAN Conference on History of Programming Languages, HOPL III, 12–1–12–55. New York, NY, USA, 2007. Association for Computing Machinery. URL: https://doi.org/10.1145/1238844.1238856, doi:10.1145/1238844.1238856.">9</a>]</span>, Algebraic Data Types are <em>composite</em>, meaning
that they are data types made from other data types. For example,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">One</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Int</span>
<span class="w">         </span><span class="o">|</span><span class="w"> </span><span class="kt">Two</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="kt">Int</span>
<span class="w">         </span><span class="o">|</span><span class="w"> </span><span class="kt">Three</span><span class="w"> </span><span class="kt">Float</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="kt">Char</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">Foo</span></code> is an algebraic data type made from the types <code class="docutils literal notranslate"><span class="pre">Int</span></code>,
<code class="docutils literal notranslate"><span class="pre">Bool</span></code>, <code class="docutils literal notranslate"><span class="pre">Float</span></code>, and <code class="docutils literal notranslate"><span class="pre">Char</span></code>. In general, these data types are
composed from <em>product types</em> and <em>sum types</em>.</p>
<p>Product types are the types on finds in most other imperative and object
oriented programming languages, such as <code class="docutils literal notranslate"><span class="pre">struct</span></code> in C or tuples in
Haskell. Product types are called so because they form the cartesian
product on the set of elements represented by the type, for example the
type <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Bool)</span></code> would be written <span class="math notranslate nohighlight">\(Int \times Bool\)</span>, and would
represent the set of all pairs of elements of the sets represented by the
types <code class="docutils literal notranslate"><span class="pre">Int</span></code> and <code class="docutils literal notranslate"><span class="pre">Bool</span></code>.</p>
<p>Sum types are often not found in imperative and object oriented languages,
but are a <em>tagged union</em> or <em>disjoint union</em> of other types. Again,
thinking in terms of sets, a sum type represents a disjoint union of two
or more types. For example <code class="docutils literal notranslate"><span class="pre">Foo</span></code> is the union of three product types
that are each <em>tagged</em> with a constructor: <code class="docutils literal notranslate"><span class="pre">One</span></code>, <code class="docutils literal notranslate"><span class="pre">Two</span></code> and <code class="docutils literal notranslate"><span class="pre">Three</span></code>.
Thus in terms of sets on might write the type <code class="docutils literal notranslate"><span class="pre">Foo</span></code> as <span class="math notranslate nohighlight">\(f \in Foo
= (Int \times Int) + (Bool \times Int) + (Float \times Bool \times Char)\)</span>.
Notice also that the type <code class="docutils literal notranslate"><span class="pre">Foo</span></code> with elements <code class="docutils literal notranslate"><span class="pre">f</span></code> are <em>structural</em> (by
its definition we know a <code class="docutils literal notranslate"><span class="pre">Foo</span></code> can only be a <code class="docutils literal notranslate"><span class="pre">One</span></code>, <code class="docutils literal notranslate"><span class="pre">Two</span></code>, or
<code class="docutils literal notranslate"><span class="pre">Three</span></code> and how many fields each of these constructors have) as opposed
to <em>nominal</em>. Nominal types are the kind of types created by a
<code class="docutils literal notranslate"><span class="pre">newtype</span></code>. They can have the same <em>representation</em> but are treated as a
wholly unique type.</p>
<div class="help-wanted admonition">
<p class="admonition-title">Help Wanted</p>
<p>I’ve tried to give a thorough description of algebraic data types
without diving into too much type theory, but I find the explanation a
bit unsatisfying. For example, it is not clear <em>why</em> these are called
<code class="docutils literal notranslate"><span class="pre">Inductive</span></code> or <code class="docutils literal notranslate"><span class="pre">Algebraic</span></code> because I deemed this was too much depth
for a glossary entry. If you have a good resource or would like to take
a stab at this entry then please make an issue and have at it!</p>
</div>
</dd>
<dt id="term-Boxed">Boxed<a class="headerlink" href="#term-Boxed" title="Link to this term">¶</a></dt><dd><p>A Boxed value is a value that is represented by a pointer to the heap. For
example, a value such as <code class="docutils literal notranslate"><span class="pre">1729</span> <span class="pre">::</span> <span class="pre">Int</span></code> is represented as:</p>
</dd>
<dt id="term-Cardinality-Analysis">Cardinality Analysis<a class="headerlink" href="#term-Cardinality-Analysis" title="Link to this term">¶</a></dt><dd><p>A static analysis that GHC performs to determine: (1) How many times a
lambda-expression is called, (2) Which components of a data structure are
never evaluated, (3) How many times a particular thunk is evaluated. See
<span id="id3">Graf [<a class="reference internal" href="../contents.html#id14" title="Sebastian Graf. Call arity vs. demand analysis. August 2017.">10</a>]</span> and <span id="id4">Sergey <em>et al.</em> [<a class="reference internal" href="../contents.html#id16" title="Ilya Sergey, Dimitrios Vytiniotis, and Simon Peyton Jones. Modular, higher-order cardinality analysis in theory and practice. SIGPLAN Not., 49(1):335–347, jan 2014. URL: https://doi.org/10.1145/2578855.2535861, doi:10.1145/2578855.2535861.">11</a>]</span> for more.</p>
</dd>
<dt id="term-Closure">Closure<a class="headerlink" href="#term-Closure" title="Link to this term">¶</a></dt><dd><p>A closure is value that pairs a function with an environment, where the
environment maps every free variable in the function with a value or
reference to which the free variable was bound when the closure was
created. Closure’s are the canonical way to realize lexical scoping in
languages with first-class functions, such a Haskell. See <a class="reference external" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">the wikipedia</a> entry for
more.</p>
</dd>
<dt id="term-Closure-Conversion">Closure Conversion<a class="headerlink" href="#term-Closure-Conversion" title="Link to this term">¶</a></dt><dd><p>Closure conversion is the default way GHC treats free variables in a
function body. Closure Conversion creates a top level record for the
original function, called the function environment, whose fields are the
free variables of the function. The environment is passed to the function
as an implicit parameter and the free variable call sites are rewritten as
field accesses. Then the function and the record are grouped in a tuple,
i.e., a closure (pair of environment and function) is created causing some
extra heap allocation. Finally the call sites of the original function are
rewritten to pass the environment with the original function. Consider
this example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">acc</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">xs</span>
<span class="kr">in</span><span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
<span class="o">...</span>
</pre></div>
</div>
<p>In this example <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are free variables in the function <code class="docutils literal notranslate"><span class="pre">f</span></code> .
Closure conversion will capture them and transform this function to:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="c1">-- the function environment</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">EnvF</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">EnvF</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="p">}</span>

<span class="c1">-- the new function</span>
<span class="nf">f_cc</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">acc</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">env</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="n">env</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span>

<span class="c1">-- the closure that replaces the original function in the same scope</span>
<span class="kr">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">f_cc</span><span class="p">,</span><span class="w"> </span><span class="kt">EnvF</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="kr">in</span><span class="w"> </span><span class="p">(</span><span class="n">fst</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">snd</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Notice closure conversion has <em>added</em> an extra <code class="docutils literal notranslate"><span class="pre">let</span></code> expression for the
closure and the reference to <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> have been replaced with
accesses to <code class="docutils literal notranslate"><span class="pre">env</span></code> . The let expression can be a source of extra heap
allocations and is one of the costs of closure conversion. However, the
benefits are uniformity; every function can be treated as a closure.
Closure conversion is often contrasted with Lambda Lifting which is
another strategy to handle free variables that does not incur extra heap
allocation. See <span id="id5">Johnsson [<a class="reference internal" href="../contents.html#id12" title="Thomas Johnsson. Lambda lifting: transforming programs to recursive equations. In Jean-Pierre Jouannaud, editor, Functional Programming Languages and Computer Architecture, 190–203. Berlin, Heidelberg, 1985. Springer Berlin Heidelberg.">6</a>]</span> and
<span id="id6">Graf and Jones [<a class="reference internal" href="../contents.html#id13" title="Sebastian Graf and Simon Peyton Jones. Selective lambda lifting. 2019. URL: https://arxiv.org/abs/1910.11717, doi:10.48550/ARXIV.1910.11717.">7</a>]</span> for more.</p>
</dd>
<dt id="term-CAF">CAF<a class="headerlink" href="#term-CAF" title="Link to this term">¶</a></dt><dd><p>A CAF, or Constant Applicative Form, is a Haskell value which contains no
free variables and is not a function. Consider these examples:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- these are CAFs</span>
<span class="c1">-- A static literal is a CAF</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">12</span>

<span class="c1">-- A reducible expression that requires no input is a CAF</span>
<span class="nf">bar</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">])</span>
<span class="nf">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])</span>

<span class="c1">-- not a lambda, curried functions that can be reduced when given an</span>
<span class="c1">-- input are CAFs</span>
<span class="nf">baz</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">baz</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span>

<span class="c1">-- not CAFs</span>
<span class="nf">qux</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">qux</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w">     </span><span class="c1">-- equivalent to baz but is a lambda so not a CAF</span>

<span class="nf">quux</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">quux</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w">      </span><span class="c1">-- x is free thus not a CAF</span>
</pre></div>
</div>
<p>These values are <em>constant</em> because they don’t bind any variables or have
any free variables. Because they are constant they are floated (see
<a class="reference internal" href="#term-Let-Floating"><span class="xref std std-term">Let Floating</span></a>) to the top of the program, and statically allocated
during compile time. Since they are statically allocated at compile time
CAFs are pinned memory and special treatment in the runtime system. Thus,
heavily allocating CAFs can increase memory residency. See
<span id="id7">Jones <em>et al.</em> [<a class="reference internal" href="../contents.html#id3" title="Peyton Jones, Simon L, and Simon Peyton Jones. Implementing lazy functional languages on stock hardware: the spineless tagless g-machine. Journal of Functional Programming, 2:127-202, July 1992. URL: https://www.microsoft.com/en-us/research/publication/implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-g-machine/.">5</a>]</span> Section 10.8 for more details.</p>
</dd>
<dt id="term-DWARF">DWARF<a class="headerlink" href="#term-DWARF" title="Link to this term">¶</a></dt><dd><p>DWARF symbols are a widely used and standardized data format used to
provide source level debugging. For more, see <a class="reference external" href="https://dwarfstd.org/">the official webpage</a>.</p>
</dd>
<dt id="term-Entry-Code">Entry Code<a class="headerlink" href="#term-Entry-Code" title="Link to this term">¶</a></dt><dd><p>The entry code for a closure on the heap is the code that will evaluate
that closure. There are some nuances and exceptions: For functions the
entry code applies the function to its arguments, which the entry code
assumes are all present; that is, the entry code assumes all arguments are
either loaded into registers or are already on the stack. Should the
function be applied to too few arguments or should the function be an
<a class="reference internal" href="#term-Unknown-function"><span class="xref std std-term">Unknown function</span></a> then a generic apply is used. For a <a class="reference internal" href="#term-PAP"><span class="xref std std-term">PAP</span></a>,
there is no entry code. PAPs can only be applied to more arguments using
the generic apply functions. Lastly, <a class="reference internal" href="#term-Unlifted"><span class="xref std std-term">Unlifted</span></a> Objects cannot be
evaluated and thus have no entry code.</p>
</dd>
<dt id="term-Full-Laziness-transformation">Full Laziness transformation<a class="headerlink" href="#term-Full-Laziness-transformation" title="Link to this term">¶</a></dt><dd><p>A form of <a class="reference internal" href="#term-Let-Floating"><span class="xref std std-term">Let Floating</span></a> which moves let bindings out of lambda
abstractions to avoid unnecessary allocation and computation. See
<span id="id8">Peyton Jones and Santos [<a class="reference internal" href="../contents.html#id5" title="Simon Peyton Jones and Andre Santos. A transformation-based optimiser for haskell. Science of Computer Programming, October 1997. URL: https://www.microsoft.com/en-us/research/publication/a-transformation-based-optimiser-for-haskell/.">2</a>]</span> Section 7.2.</p>
</dd>
<dt id="term-Fusion">Fusion<a class="headerlink" href="#term-Fusion" title="Link to this term">¶</a></dt><dd><p>See <a class="reference internal" href="Preliminaries/what_makes_fast_hs.html#canonical-fusion"><span class="std std-ref">What is Fusion</span></a>.</p>
</dd>
<dt id="term-HNF">HNF<a class="headerlink" href="#term-HNF" title="Link to this term">¶</a></dt><dd><p>An expression that is in <em>head normal form</em> is a value which contains at
least one <a class="reference internal" href="#term-Thunk"><span class="xref std std-term">thunk</span></a>. If the value does not contain any thunks, then it
is said to be in normal form (<a class="reference internal" href="#term-NF"><span class="xref std std-term">NF</span></a>). See
<span id="id9">Jones <em>et al.</em> [<a class="reference internal" href="../contents.html#id3" title="Peyton Jones, Simon L, and Simon Peyton Jones. Implementing lazy functional languages on stock hardware: the spineless tagless g-machine. Journal of Functional Programming, 2:127-202, July 1992. URL: https://www.microsoft.com/en-us/research/publication/implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-g-machine/.">5</a>]</span> Section 3.1 for more.</p>
</dd>
<dt id="term-Info-Table">Info Table<a class="headerlink" href="#term-Info-Table" title="Link to this term">¶</a></dt><dd><p>Every heap allocated object in the runtime system keeps an information
table that stores data such as: the object type (function, data
constructor, thunk etc.) before the payload of the object. This is called
the Info Table. See <span id="id10">Marlow <em>et al.</em> [<a class="reference internal" href="../contents.html#id11" title="Simon Marlow, Alexey Rodriguez Yakushev, and Simon Peyton Jones. Faster laziness using dynamic pointer tagging. SIGPLAN Not., 42(9):277–288, oct 2007. URL: https://doi.org/10.1145/1291220.1291194, doi:10.1145/1291220.1291194.">4</a>]</span>, <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/heap-objects#info-tables">wiki</a>, and
<span id="id11">Peyton Jones and Salkild [<a class="reference internal" href="../contents.html#id7" title="Simon L. Peyton Jones and Jon Salkild. The spineless tagless g-machine. In Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture, FPCA '89, 184–201. New York, NY, USA, 1989. Association for Computing Machinery. URL: https://doi.org/10.1145/99370.99385, doi:10.1145/99370.99385.">12</a>]</span> Section 7.1 for more details.</p>
</dd>
<dt id="term-Info-Table-Address">Info Table Address<a class="headerlink" href="#term-Info-Table-Address" title="Link to this term">¶</a></dt><dd><p>The memory address for heap object descriptors <a class="reference internal" href="#term-Info-Table"><span class="xref std std-term">info table</span></a>.</p>
</dd>
<dt id="term-Join-Point">Join Point<a class="headerlink" href="#term-Join-Point" title="Link to this term">¶</a></dt><dd><p>A join point is a place where different execution paths come together or
<em>join</em>. Consider this example slightly modified from
<span id="id12">Maurer <em>et al.</em> [<a class="reference internal" href="../contents.html#id2" title="Luke Maurer, Paul Downen, Zena M. Ariola, and Simon Peyton Jones. Compiling without continuations. In Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2017, 482–494. New York, NY, USA, 2017. Association for Computing Machinery. URL: https://doi.org/10.1145/3062341.3062380, doi:10.1145/3062341.3062380.">13</a>]</span>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">join1</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">some_large_expression</span>
<span class="w">    </span><span class="n">join2</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">some_other_large_expr</span>
<span class="kr">in</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="p">(</span><span class="kr">if</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">join1</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">join2</span><span class="w"> </span><span class="nb">()</span><span class="p">)</span>
<span class="w">         </span><span class="kr">else</span><span class="w"> </span><span class="p">(</span><span class="kr">if</span><span class="w"> </span><span class="n">e3</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">join1</span><span class="w"> </span><span class="nb">()</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="n">join2</span><span class="w"> </span><span class="nb">()</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">join1</span></code> and <code class="docutils literal notranslate"><span class="pre">join2</span></code> are join points because the
branches described by each if-expression conclude by calling them. Thus,
the control flow described by the if-expressions joins at specifically
<code class="docutils literal notranslate"><span class="pre">join1</span></code> and <code class="docutils literal notranslate"><span class="pre">join2</span></code>. Join points are an important optimization
technique that GHC performs automatically to remove redundant allocations.
Had we not wrapped <code class="docutils literal notranslate"><span class="pre">some_large_expression</span></code> and <code class="docutils literal notranslate"><span class="pre">some_other_large_expr</span></code>
in a <code class="docutils literal notranslate"><span class="pre">let</span></code>, then these expressions would be duplicated <em>and</em> would be
captured in an additionally allocated closure unnecessarily. Join points
avoid these problems and are particularly relevant for Stream
<a class="reference internal" href="#term-Fusion"><span class="xref std std-term">Fusion</span></a> performance. For more see the join points paper:
<span id="id13">Maurer <em>et al.</em> [<a class="reference internal" href="../contents.html#id2" title="Luke Maurer, Paul Downen, Zena M. Ariola, and Simon Peyton Jones. Compiling without continuations. In Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2017, 482–494. New York, NY, USA, 2017. Association for Computing Machinery. URL: https://doi.org/10.1145/3062341.3062380, doi:10.1145/3062341.3062380.">13</a>]</span>.</p>
</dd>
<dt id="term-Known-Function">Known Function<a class="headerlink" href="#term-Known-Function" title="Link to this term">¶</a></dt><dd><p>A known function is a function in the STG machine of which GHC statically
knows the <a class="reference internal" href="#term-Entry-Code"><span class="xref std std-term">Entry Code</span></a> pointer and the <a class="reference internal" href="#term-Arity"><span class="xref std std-term">Arity</span></a> of. This means
that the function binding site is statically visible, that is, the
function is <a class="reference internal" href="#term-Top-Level"><span class="xref std std-term">Top-Level</span></a>, or the function is bound by an enclosing
<code class="docutils literal notranslate"><span class="pre">let</span></code>. With this information the STG machine can use a faster function
application procedure because the function pointer does not need to be
scrutinized. See also <a class="reference internal" href="#term-Unknown-function"><span class="xref std std-term">Unknown Function</span></a>.</p>
</dd>
<dt id="term-Levity-Polymorphism">Levity Polymorphism<a class="headerlink" href="#term-Levity-Polymorphism" title="Link to this term">¶</a></dt><dd><p>A kind of polymorphism that abstracts over calling conventions which
allows levity polymorphic functions to be abstracted over memory layout.
See <span id="id14">Eisenberg and Peyton Jones [<a class="reference internal" href="../contents.html#id9" title="Richard A. Eisenberg and Simon Peyton Jones. Levity polymorphism. SIGPLAN Not., 52(6):525–539, jun 2017. URL: https://doi.org/10.1145/3140587.3062357, doi:10.1145/3140587.3062357.">14</a>]</span> for a more precise technical definition
and discussion.</p>
</dd>
<dt id="term-Let-Floating">Let Floating<a class="headerlink" href="#term-Let-Floating" title="Link to this term">¶</a></dt><dd><p>A group of optimizing transformation’s that move <code class="docutils literal notranslate"><span class="pre">let</span></code> bindings to
reduce heap allocations. See <span id="id15">Partain <em>et al.</em> [<a class="reference internal" href="../contents.html#id8" title="WD Partain, A Santos, and Simon Peyton Jones. Let-floating: moving bindings to give faster programs. May 1996. ACM SIGPLAN International Conference on Functional Programming (ICFP'96). URL: https://www.microsoft.com/en-us/research/publication/let-floating-moving-bindings-to-give-faster-programs/.">15</a>]</span> and
<span id="id16">Peyton Jones and Santos [<a class="reference internal" href="../contents.html#id5" title="Simon Peyton Jones and Andre Santos. A transformation-based optimiser for haskell. Science of Computer Programming, October 1997. URL: https://www.microsoft.com/en-us/research/publication/a-transformation-based-optimiser-for-haskell/.">2</a>]</span> Section 7 for more details.</p>
</dd>
<dt id="term-Lifted">Lifted<a class="headerlink" href="#term-Lifted" title="Link to this term">¶</a></dt><dd><p>A Lifted type is a type that contains the value <span class="math notranslate nohighlight">\(\bot\)</span>; which means
the type is lazy and capable of representing non-terminating computation.
For example, the <code class="docutils literal notranslate"><span class="pre">Bool</span></code> type is a set with three values: <code class="docutils literal notranslate"><span class="pre">True</span></code>,
<code class="docutils literal notranslate"><span class="pre">False</span></code>, and <span class="math notranslate nohighlight">\(\bot\)</span>. Therefore <code class="docutils literal notranslate"><span class="pre">Bool</span></code> is a Lifted type.</p>
</dd>
<dt id="term-Loop-Fusion">Loop Fusion<a class="headerlink" href="#term-Loop-Fusion" title="Link to this term">¶</a></dt><dd><p>Loop fusion is a classic optimization technique that reduces the number of
loops in a program, thereby reducing the number of memory accesses and the
number of looping constructs. In Haskell, loop fusion transforms many
traversals over the same data structure to a single traversal. A classic
example of this is map fusion.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- two traversals, one for f, one for g on the result of f</span>
<span class="nf">map</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>

<span class="c1">-- after map fusion:</span>
<span class="c1">-- only one traversal</span>
<span class="nf">map</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</pre></div>
</div>
<p>This can also appear in list comprehensions, for example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="c1">-- three traversals: two to project elements, 1 to fold</span>
<span class="kr">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="p">]</span>
<span class="kr">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="n">foo</span><span class="w">   </span><span class="p">[</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="p">]</span>

<span class="c1">-- after loop fusion on the list comprehensions</span>
<span class="c1">-- 2 traversals: one for the arguments, one to fold</span>
<span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="w"> </span><span class="n">js</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">unzip</span><span class="w"> </span><span class="n">args</span>
<span class="kr">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">is</span>
<span class="kr">let</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">js</span>
</pre></div>
</div>
</dd>
<dt id="term-Multi-Shot-Lambda">Multi-Shot Lambda<a class="headerlink" href="#term-Multi-Shot-Lambda" title="Link to this term">¶</a></dt><dd><p>A multi-shot lambda is a lambda that is called <em>more</em> than once. In
contrast to a <a class="reference internal" href="#term-One-Shot-Lambda"><span class="xref std std-term">one-shot lambda</span></a>, a multi-shot lambda has a high risk
of destroying <a class="reference internal" href="#term-Sharing"><span class="xref std std-term">sharing</span></a> if subject to certain optimizations, such as
Inlining. GHC determines whether a lambda is one-shot or multi-shot during
<a class="reference internal" href="#term-Cardinality-Analysis"><span class="xref std std-term">Cardinality Analysis</span></a>. See <span id="id17">Sergey <em>et al.</em> [<a class="reference internal" href="../contents.html#id16" title="Ilya Sergey, Dimitrios Vytiniotis, and Simon Peyton Jones. Modular, higher-order cardinality analysis in theory and practice. SIGPLAN Not., 49(1):335–347, jan 2014. URL: https://doi.org/10.1145/2578855.2535861, doi:10.1145/2578855.2535861.">11</a>]</span> and
<span id="id18">Graf [<a class="reference internal" href="../contents.html#id14" title="Sebastian Graf. Call arity vs. demand analysis. August 2017.">10</a>]</span> for more.</p>
</dd>
<dt id="term-NF">NF<a class="headerlink" href="#term-NF" title="Link to this term">¶</a></dt><dd><p>An expression that is in <em>normal form</em> is a fully evaluated expression and
is a value which contains no thunks. This is in contrast to weak head
normal form (<a class="reference internal" href="#term-WHNF"><span class="xref std std-term">WHNF</span></a>) and head normal form (<a class="reference internal" href="#term-HNF"><span class="xref std std-term">HNF</span></a>), both of
which may contain thunks. See <span id="id19">Jones <em>et al.</em> [<a class="reference internal" href="../contents.html#id3" title="Peyton Jones, Simon L, and Simon Peyton Jones. Implementing lazy functional languages on stock hardware: the spineless tagless g-machine. Journal of Functional Programming, 2:127-202, July 1992. URL: https://www.microsoft.com/en-us/research/publication/implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-g-machine/.">5</a>]</span> Section 3.1
for more.</p>
</dd>
<dt id="term-Occurrence-Name">Occurrence Name<a class="headerlink" href="#term-Occurrence-Name" title="Link to this term">¶</a></dt><dd><p>An Occurrence name is a name GHC assigns to an entity to disambiguate
multiple occurrences of that name. Disambiguation allows GHC to distinguish
<em>by name</em> a type constructor from a data constructor, which often occurs
due to punning, or from local variables in separate functions with the same
name, such as <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">xs</span></code>. Occurrence names are a pair of the original
name (as a <code class="docutils literal notranslate"><span class="pre">FastString</span></code>, a GHC internal type) and a <code class="docutils literal notranslate"><span class="pre">NameSpace</span></code>; they
are ubiquitous in GHC and in the intermediate representations. For example,
the occurrence name for the function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">...</span></code> will be similar to
<code class="docutils literal notranslate"><span class="pre">f_r17p</span></code>. The exact occurrence name will change, but parts are static.
For example, the <code class="docutils literal notranslate"><span class="pre">f</span></code> before the underscore always comes from the name of
the function. Had <code class="docutils literal notranslate"><span class="pre">f</span></code> been name <code class="docutils literal notranslate"><span class="pre">fancyFunction</span></code> then the ocurrence name
would have been <code class="docutils literal notranslate"><span class="pre">fancyFunction_r17p</span></code>. Similarly, leading character in the
suffix; the <code class="docutils literal notranslate"><span class="pre">r</span></code> in <code class="docutils literal notranslate"><span class="pre">r17p</span></code> is static and meaningful. In this case, the
<code class="docutils literal notranslate"><span class="pre">r</span></code> indicates that the name <code class="docutils literal notranslate"><span class="pre">f</span></code> is an element in the <code class="docutils literal notranslate"><span class="pre">NameCache</span></code>,
meaning that all references to <code class="docutils literal notranslate"><span class="pre">f</span></code> share a single <code class="docutils literal notranslate"><span class="pre">Unique</span></code> ID in every
GHC invocation (See the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/blob/master/compiler/GHC/Types/Name/Cache.hs?ref_type=heads#L36">Note [The Name Cache]</a> for more). When
occurrence names are generated, the leading character is a hint for what
kind of name is being generated. You can find an incomplete list of tags
and their meanings in <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/blob/master/compiler/GHC/Builtin/Uniques.hs?ref_type=heads#L305">Note [Uniques for wired-in prelude things
and known tags]</a>. For
more on names see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/blob/master/compiler/GHC/Iface/Tidy.hs?ref_type=heads#L271">Note [Choosing external Ids]</a> and <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/rdr-name-type#the-occname-type">this</a>
wiki page on GHC’s Reader names.</p>
</dd>
<dt id="term-One-Shot-Lambda">One-Shot Lambda<a class="headerlink" href="#term-One-Shot-Lambda" title="Link to this term">¶</a></dt><dd><p>A one-shot lambda is a lambda that is called <em>exactly</em> once. These
lambda’s are common in functional programming and can be subject to more
aggressive optimizations due to their one-shot nature. For example, there
is no risk of losing <a class="reference internal" href="#term-Sharing"><span class="xref std std-term">sharing</span></a> in a one-shot lambda as a result of
inlining free variables or floating let expressions <em>into</em> the lambda;
something that GHC usually avoids. See <span id="id20">Sergey <em>et al.</em> [<a class="reference internal" href="../contents.html#id16" title="Ilya Sergey, Dimitrios Vytiniotis, and Simon Peyton Jones. Modular, higher-order cardinality analysis in theory and practice. SIGPLAN Not., 49(1):335–347, jan 2014. URL: https://doi.org/10.1145/2578855.2535861, doi:10.1145/2578855.2535861.">11</a>]</span> and
<span id="id21">Graf [<a class="reference internal" href="../contents.html#id14" title="Sebastian Graf. Call arity vs. demand analysis. August 2017.">10</a>]</span> for more background. See the magic
<a class="reference external" href="https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-Exts.html#v:oneShot">oneShot</a>
function in <a class="reference external" href="https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-Exts.html">GHC.Exts</a>
for an unsafe way to instruct GHC that you have a one-shot lambda.</p>
</dd>
<dt id="term-PAP">PAP<a class="headerlink" href="#term-PAP" title="Link to this term">¶</a></dt><dd><p>A PAP is a partial application. PAPs are heap objects and thus a type of
closure that represents a function applied to <em>too few</em> arguments. PAPs
should never be entered, and are only applied using the generic apply
functions in the STG machine. See the file <code class="docutils literal notranslate"><span class="pre">rts/Apply.cmm</span></code> in GHC or the
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/heap-objects">heap object</a> wiki page for
more.</p>
</dd>
<dt id="term-Pinned">Pinned<a class="headerlink" href="#term-Pinned" title="Link to this term">¶</a></dt><dd><p>Pinned memory is memory that is guaranteed to not be moved by GHC’s garbage
collector. This is most often useful for interfacing with foreign code.
Note that pinned memory may lead to memory fragmentation and increased slop
because it never moves. See <a class="reference external" href="https://well-typed.com/blog/2020/08/memory-fragmentation/">Well Typed’s</a> post and the
<a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/storage/gc/pinned">wiki</a>
for more.</p>
</dd>
<dt id="term-Reproducer">Reproducer<a class="headerlink" href="#term-Reproducer" title="Link to this term">¶</a></dt><dd><p>A reproducer is the smallest known program that induces incorrect behavior
in the system. See <a class="reference internal" href="Preliminaries/how_to_debug.html#make-it-fail"><span class="std std-ref">Make it Fail</span></a> for more.</p>
</dd>
<dt id="term-Sharing">Sharing<a class="headerlink" href="#term-Sharing" title="Link to this term">¶</a></dt><dd><p>Consider the following program:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">foo</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">]</span>
<span class="w">            </span><span class="kr">in</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="p">(</span><span class="n">fmap</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">last</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">x</span>
</pre></div>
</div>
<p>We say that <code class="docutils literal notranslate"><span class="pre">x</span></code> is <em>shared</em> in this program because each of the three
references of <code class="docutils literal notranslate"><span class="pre">x</span></code> refer to the <code class="docutils literal notranslate"><span class="pre">x</span></code> defined in the <code class="docutils literal notranslate"><span class="pre">let</span></code>. If <code class="docutils literal notranslate"><span class="pre">x</span></code> is
not shared that the list <code class="docutils literal notranslate"><span class="pre">[1..n]</span></code> would be allocated <em>for each</em>
reference of <code class="docutils literal notranslate"><span class="pre">x</span></code>. Thus, sharing is fundamental to performance oriented
Haskell because it reduces allocations, leverages call-by-need, and saves
work.</p>
</dd>
<dt id="term-Shotgun-Debugging">Shotgun Debugging<a class="headerlink" href="#term-Shotgun-Debugging" title="Link to this term">¶</a></dt><dd><p>Debugging with hope instead of process and measurement. See its Wikepedia
<a class="reference external" href="https://en.wikipedia.org/wiki/Shotgun_debugging">entry</a>.</p>
</dd>
<dt id="term-SRT">SRT<a class="headerlink" href="#term-SRT" title="Link to this term">¶</a></dt><dd><p>Static reference tables are how GHC’s garbage collector determines the
live <a class="reference internal" href="#term-CAF"><span class="xref std std-term">CAF</span></a>’s of a program. SRTs are stored in a heap object’s
<a class="reference internal" href="#term-Info-Table"><span class="xref std std-term">Info Table</span></a> and are simply an object in the compiled programs data
segment. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/blob/master/compiler/GHC/Cmm/Info/Build.hs#L51">The SRT Note</a>
in <code class="docutils literal notranslate"><span class="pre">GHC.Cmm.Info.Build</span></code> for more details.</p>
</dd>
<dt id="term-Thunk">Thunk<a class="headerlink" href="#term-Thunk" title="Link to this term">¶</a></dt><dd><p>A thunk is a special kind of <a class="reference internal" href="#term-Closure"><span class="xref std std-term">Closure</span></a> that represents a suspended
computation. Thunks reside on the heap and are the key feature that
provides Haskell’s laziness. See <span id="id22">Peyton Jones and Salkild [<a class="reference internal" href="../contents.html#id7" title="Simon L. Peyton Jones and Jon Salkild. The spineless tagless g-machine. In Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture, FPCA '89, 184–201. New York, NY, USA, 1989. Association for Computing Machinery. URL: https://doi.org/10.1145/99370.99385, doi:10.1145/99370.99385.">12</a>]</span>
Section 3.1.2 for more details.</p>
</dd>
<dt id="term-Thread-State-Object-TSO">Thread State Object (TSO)<a class="headerlink" href="#term-Thread-State-Object-TSO" title="Link to this term">¶</a></dt><dd><p>A thread state object is a heap object that represents a Haskell thread in
GHC’s runtime system. For the precise contents please see its definition
in <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/blob/master/rts/include/rts/storage/TSO.h?ref_type=heads">GHC’s source code</a> and <a class="reference external" href="https://youtu.be/5vKBFnTsCcE?si=4THBS_KMYRI6U1Sm&amp;t=4620">this description</a> by Ben
Gamari.</p>
</dd>
<dt id="term-Top-Level">Top-Level<a class="headerlink" href="#term-Top-Level" title="Link to this term">¶</a></dt><dd><p>The most outer-most or global scope of the program.</p>
</dd>
<dt id="term-Unboxed">Unboxed<a class="headerlink" href="#term-Unboxed" title="Link to this term">¶</a></dt><dd><p>An UnBoxed value is a value that is represented by the value itself.
UnBoxed values therefore cannot be lazy, like boxed values.</p>
</dd>
<dt id="term-Unlifted">Unlifted<a class="headerlink" href="#term-Unlifted" title="Link to this term">¶</a></dt><dd><p>An Unlifted type is a type where <span class="math notranslate nohighlight">\(\bot\)</span> <em>is not</em> an element of that
type. See <a class="reference internal" href="#term-Levity-Polymorphism"><span class="xref std std-term">Levity Polymorphism</span></a> and <a class="reference internal" href="#term-Lifted"><span class="xref std std-term">Lifted</span></a> types for more.</p>
</dd>
<dt id="term-Unknown-function">Unknown function<a class="headerlink" href="#term-Unknown-function" title="Link to this term">¶</a></dt><dd><p>An unknown function is a function in the STG machine whose <a class="reference internal" href="#term-Entry-Code"><span class="xref std std-term">Entry
Code</span></a> pointer and <a class="reference internal" href="#term-Arity"><span class="xref std std-term">Arity</span></a> are not statically known by GHC. Unknown
functions require GHC to generate code that first scrutinizes the function
pointer to determine its arity and then dispatch to the normal function
call handling procedures. This in known has a generic apply in the STG
machine and is slower (due to needing to scrutinize the function) than a
<a class="reference internal" href="#term-Known-Function"><span class="xref std std-term">Known function</span></a>. See <span id="id23">Marlow and Jones [<a class="reference internal" href="../contents.html#id15" title="Simon Marlow and Simon Peyton Jones. Making a fast curry: push/enter vs. eval/apply for higher-order languages. In Proceedings of the Ninth ACM SIGPLAN International Conference on Functional Programming, ICFP '04, 4–15. New York, NY, USA, 2004. Association for Computing Machinery. URL: https://doi.org/10.1145/1016850.1016856, doi:10.1145/1016850.1016856.">3</a>]</span> for more details on STG
calling conventions.</p>
</dd>
<dt id="term-Unfolding">Unfolding<a class="headerlink" href="#term-Unfolding" title="Link to this term">¶</a></dt><dd><p>An Unfolding of an identifier, as defined in <code class="docutils literal notranslate"><span class="pre">GHC.Core.Unfold</span></code>, is the
<em>approximate</em> form the identifier would have if the identifier’s
definition was substituted for the identifier. That is, Unfoldings are
generally the right hand sides or bodies of function definitions untouched
by optimizations. Unfoldings appear in Core and Interface files to enable
cross-module inlining and optimizations. See the <a class="reference internal" href="Measurement_Observation/Core_Profiling/core.html#reading-core"><span class="std std-ref">Reading Core</span></a> chapter for more.</p>
</dd>
<dt id="term-WHNF">WHNF<a class="headerlink" href="#term-WHNF" title="Link to this term">¶</a></dt><dd><p>An expression is in <em>weak head normal form</em> if it has been evaluated to
its’ outermost data constructor or lambda abstraction (i.e., <em>the head</em>).
See <a class="reference external" href="https://stackoverflow.com/questions/6872898/what-is-weak-head-normal-form/6889335#6889335">this</a>
post, <a class="reference external" href="https://wiki.haskell.org/Weak_head_normal_form">the wiki</a> , and
<a class="reference external" href="https://en.wikipedia.org/wiki/Lambda_calculus_definition#Weak_head_normal_form">wikipedia</a>
for more.</p>
</dd>
</dl>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="Case_Studies/klister.html"
       title="previous chapter">← <span class="section-number">4.3. </span><span class="incremental">Klister: A First Pass Performance Engineering</span></a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; Copyright 2022-2024, Jeffrey Young (doyougnu).
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.2.6 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>